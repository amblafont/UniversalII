-question for ambrus : how do you do local modules (module M = ..) as an alias ?
Formalisation of the universal datatype which is hoped to be enough to encode any Inductive-Inductive datatype.

This universal datatype can be described as an Inductive-Inductive-Recursive datatype, or as un Quotient-Inductive-Inductive Datatype. Here, we formalize it in agda using UIP and even rewrite rules (useful to tame the coherence hell) as an indexed datatype (preterms and then typing judgements). The aim is to produce the non dependent recursor and prove its unicity

List of files
- monlib: some useful lemmas about equalities (using UIP)
- Syntax: the syntax of the universal datatype
- Model: axiomatization of a model (using rewrite rules)
- Relation: definition of the functional relation enjoyed by the non dependent recursor
- RelationProp: proof that any syntax term relates to at most one model term (uses UIP)
- RelationWeakening: proof that weakening preserves the relation
- RelationSubst: proof that substitution preserves the relation 
- RelationInhabit: proof that any syntax term relates to a model term. Hence the relation is functional.

- ModelRecord : definition of a model as a record (without rewrite rules)
- ModelRewIsRecord* : the postulated model with rewrite rules is a model (as a record)
- SyntaxIsRecord* : the syntax is a model (as a record def)

- ModelMorphism : definition of model morphisms between models as records

- InitialMorphism* : definition of the model morphism between the syntax and the model with rewrite rules 

- ModelMorRew : postulation of a model morphism from the syntax to the postulated model, using rewrite rules

- UniversalIIT: deprecated old file 

TODO:
- rename commutation lemmas in Syntax (subt-wkt and so on) and Model
- prove uniqueness of the initial model morphism (by postulating it)
