We work in the setting of extensional type theory, although we occasionally indicate through $e_1,\dots,e_n \#
t$ that $t$ is well-typed thanks to the equalities $e_1$,\dots,$e_n$.
% We are also careful to explain where UIP or functional extensionality that is
% available in extensional type theory are used.

The construction consists of the following steps:
\begin{enumerate}
\item Definition of untyped syntax (as a family of inductive datatypes) together
  with typing judgments (as inductive relations on the untyped
  syntax), and construction of a model of the theory of IIT
  signatures from well-formed terms, denoted $S$.
\item Construction of a morphism $\rec:S\to M$ for arbitrary $M$, by:
  \begin{enumerate}
  \item defining a relation $\blank \sim \blank$ between the (well-typed) syntax and a given
    model. The idea is that given a syntactic context $\Gamma$ and a semantic
    context $\model{\Gamma}$ of the model $M$, we have $\Gamma \sim
    \model{\Gamma}$ if and only if $\rec\,\,\Gamma = \model{\Gamma}$, and
    similarly for types, terms, and substitutions;
    % semantic context $\model{\Gamma}$ of
    % the model $M$ if and only if $\Gamma$ relates to $\rec\,{\Gamma}$;
    % enjoyed by the initial morphism from the
    % syntax to a given model;
  \item showing that this relation is functional.
    \end{enumerate}
  \item Proving the uniqueness of this morphism by showing that any morphism
    $f:S\to M$ satisfies the relation. For example, for any syntactic context
    $\Gamma$ we have $\Gamma\sim f\,\Gamma$.
      % TODO donner composantes sur les contextes
\end{enumerate}
The next sections detail each of these steps.
\subsection{Syntactic Model}

The goal is to define the syntactic model where contexts are pairs of a
precontext together with a well-formedness proof, and similarly for types, terms
and substitutions.

Crucially, we do not have conversion relations for typed syntax, nor do we need
to use quotients when giving the syntactic model. This is possible because there
are no $\beta$-rules in the theory of signatures. Hence, we consider only normal
terms in the untyped syntax, and define weakening and substitution by recursion.
Avoiding quotients is important for two reasons. First, it greatly simplifies
formalisation. Second, we aim to reduce IITs to a minimal feature set, and we
get a stronger result if we do not use quotients.

The next sections present the definition of the untyped syntax and the
associated typing judgments.

\subsubsection{Untyped syntax}
The untyped syntax is defined as the following inductive datatype:
\todo{András: two columns below perhaps}
\begin{alignat*}{5}
  & \rlap{(1) Substitution calculus} \\[0.5em]
  & \Conu && : \Set \\
  & \Tyu  && : \Set \\
  & \Subu  && : \Set \\
  % & \Subpre  && : \Set \\
  & \Tmu  && : \Set \\
  & \emptyu && : \Conu \\
    & \epsilonu && : \Subu \\
  & \blank\extu\blank && : \Conu\ra\Tyu\ra\Conu \\
  & \blank\consu\blank && : \Subu\ra\Tmu\ra\Subu \\
  & \varu  && : \N \ra \Tmu \\
  & \rlap{(2) Sorts and operators} \\[0.5em]
  & \Uu && : \Tyu \\
  & \Elu && : \Tmu\ra\Tyu \\
  & \rlap{(3) Parameters} \\[0.5em]
  & \Piu && : \Tmu\ra\Tyu\ra\Tyu \\
  & \blank\appu\blank && : \Tmu\ra\Tmu\ra \Tmu \\
  & \rlap{(4-5) Metatheoretic and infinitary parameters} \\[0.5em]
  & \Pimu && : (T:\Set)\ra(T\ra\Tyu)\ra\Tyu \\
  & \Piiu && : (T:\Set)\ra(T\ra\Tmu)\ra\Tmu \\
  & \blank\appmu \blank && : \Tmu\ra(\alpha:T) \ra\Tmu\\
  & \rlap{(6) Default value} \\[0.5em]
  & \erru && : \Tmu
\end{alignat*}
Note that we overload the constructor for untyped application for infinitary and
meta-theoretic parameters. Variables are modeled as de Bruijn indices, i.e.\ as
natural numbers pointing to a position in the context.

% The type of (untyped) substitution is then defined as $\Subu = \List\,\Tmu$.
% Note that $\Conu$ could also be defined as a list of types in a similar fashion.

\subsubsection{Untyped weakening}


% Substitutions of types and terms are defined recursively.


Note that $(\Piu \,A\,B)[\sigma]$ should be defined as $\Piu
\,A[\sigma]\,B[\varu\, 0 \,\consu\, \wkO\,\sigma]$, and thus we need to define
$\wk0$, the weakening of substitutions.  The basic idea is to increment the de
Bruijn indices of all the variables.  Actually this is not so simple because of
the $\Piu$ type: indeed, we want to define $\wk(\Piu\,A\,B)$ as the $\Pi$ type
of the weakening of $A$ and $B$, but here, $B$ must be weakened with respect to
the second last variable of the context, rather than the last one.  For this
reason, we need to generalize the weakening as occuring anywhere in the context.
\begin{alignat*}{5}
  & \wk_n && :  \Tyu\ra\Tyu \\
  & \wk_n && :  \Tmu\ra\Tmu \\
  % & \wk && : \N \ra \N\ra\N \\
  & \wkO && : \Subu\ra \Subu
  \end{alignat*}
  The natural number $n$ specifies at which position of the context the
  weakening occurs.
  Here, $\wkO$ weakens with respect to the last variable.

Later, in Section~\ref{ss:weaken-typing}, we show that weakening preserves
typing. Stating a typing rule for this operation requires to have a way to
express the weakening occuring at the middle of a context. We consider pairs of
untyped contexts, which should be thought of as a splitting of a context at some
position. The full context is recovered by merging the two components:
% (which appears in the typing rule of a weakening occuring in the middle of a context),
% and the length $\length{\Gamma}$ of a
% context $\Gamma$:
\begin{alignat*}{5}
  & \blank \merge \blank && :  \Conu\ra\Conu\ra\Conu \\
  & \Gamma \merge \cdot && :=  \Gamma \\
  & \Gamma \merge (\Delta \extu A) && :=  (\Gamma \merge \Delta)\extu A
\end{alignat*}
We think of the second context as a telescope over the first one. We also define
weakening for telescopes, which will be used to give typing rules for telescopes
in Section \ref{sec:typing_judgments}:
\begin{alignat*}{5}
  & \wkO && : \Conu\ra \Conu
  \\
  & \wkO\,\emptyu && := \emptyu
  \\
  & \wkO\,(\Delta\,\extu A) && := \wkO\,\Delta\,\extu \wk_{\length{\Delta}}\,A
  \end{alignat*}
  \subsubsection{Untyped substitution}
  We define single substitution by recursion on presyntax:
  % & \rlap{(1) Substitution calculus} \\[0.5em]
\begin{alignat*}{5}
  & \blank[\blank := \blank] && : \Tyu\ra\N\ra\Tmu\ra\Tyu \\
  & \blank[\blank := \blank] && : \Tmu\ra\N\ra\Tmu\ra\Tmu
  % \\
  % & \blank[\blank := \blank] && : \N\ra\N\ra\Tmu\ra\Tmu
  \end{alignat*}
  This is enough to define the typing judgments: indeed, the typing rule for application
  involves only a unary substitution.

  However, to construct the initial model of the QIIT, we need to define
  the full substitution calculus:
\begin{alignat*}{5}
  & \blank[\blank] && : \Tyu\ra\Subu\ra\Tyu \\
  & \blank[\blank] && : \Tmu\ra\Subu\ra\Tmu \\
  & \blank \circ \blank && : \Subu\ra\Subu\ra \Subu
  \end{alignat*}
  These can be defined either by iterating unary substitutions, or by recursion
  on untyped syntax: the two ways yield provably equal definitions. In the
  following, we assume that it is defined by recursion.
 We use the additional default constructor $\erru:\Tmu$ in case of error (for
example, when the substitution is not long enough).  This is an irrelevant
constructor in the end, as the typing judgments will not mention it. We also
make use of the following definition:
  \begin{alignat*}{5}
  % liftV (S (n + p)) (liftV n q) ≡ liftV n (liftV (n + p) q)
  & \keep && : \Subu \ra \Subu \\
   &&& := \lambda \sigma. \varu\, 0 \,\consu\, \wkO\,\sigma
  \end{alignat*}
  The idea is that if $\sigma$ is a substitution between contexts $\Gamma$ and
  $\Delta$, then $\keep\,\sigma$ is a substitution between contexts $\Gamma, A[\sigma]$
  and $\Delta,A$ for any type $A$. This occurs when defining
  $(\Piu\,A\,B)[\sigma]$ as $\Piu (A[\sigma])(B[\keep \,\sigma])$.




  We can define the identity substitution on a context $\Gamma$ as follows,
  where $\length{\Gamma}$ is the length of the context $\Gamma$, and
  $\keep^{\length{\Gamma}}$ is $\keep$ iterated $\length{\Gamma}$ times:
\begin{alignat*}{5}
  & \length{\Gamma} && : \Conu\ra\N
  \\
  & \idu && : \Conu \ra \Subu \\
  & && := \lambda \Gamma.\keep^{\length{\Gamma}} \epsilonu
  \end{alignat*}


  \subsubsection{Exchange laws: weakening and substitution}
  Many lemmas for types and terms are shown by induction on the untyped syntax.
  Below, $Z$ denotes either a term or a type.
\begin{alignat*}{5}
  % liftV (S (n + p)) (liftV n q) ≡ liftV n (liftV (n + p) q)
  & \wk\mhyphen\wk && : \wk_{n+p+1} (\wk_n\,Z) = \wk_n(\wk_{n+p}\,Z)\\
  % n-subZ-wkZ : ∀ n A z → (lifZZ n A) [ n ↦ z ]Z  ≡ A
  & \wk_n[n] && : (\wk_{n} Z)[ n := z] = Z \\
  % lifZ-l-subV : ∀ n p u x → lifZZ (n + p) (x [ n ↦ u ]V) ≡ (lifZV (S (n + p)) x) [ n ↦ (lifZZ p u) ]V
  & \wk_+[] && : (\wk_{n+p+1} Z)[ n := \wk_p u] = \wk_{n+p}(Z[n := u]) \\
  % l-subV-lifZV : ∀ Δ u n x → (lifZV n x) [ (S (n + Δ)) ↦ u ]V  ≡ lifZZ n (x [ (n + Δ) ↦ u ]V)
  & \wk[+] && : (\wk_{n} Z)[ n+p+1 :=  u] = \wk_{n}(Z[n+p := u]) \\
  % l-subV-l-subV : ∀ n p z u x →  (x [ n ↦ u ]V) [ (n + p) ↦ z ]Z  ≡ (x [ (S (n + p)) ↦ z ]V) [ n ↦ (u [ p ↦ z ]Z) ]Z
  & [][+] && : Z[n :=u][n+p:=z] = Z[n+p+1:=z][n:= (u[p:=z])]
  \end{alignat*}
  Below, $\keep^n$ denotes $\keep$ iterated $n$ times.
\begin{alignat*}{5}
  % liftV (S (n + p)) (liftV n q) ≡ liftV n (liftV (n + p) q)
  % liftV=wkS
  & [\keep^n\mhyphen \wkO] && : Z[\keep^n (\wkO\,\sigma)] = \wk_n (Z[\keep^n\,\sigma])
  \\
  % lifZₛV : ∀ n xp σp Zp → (lifZV n xp [ iZer n keep (Zp ∷ σp) ]V) ≡ (xp [ iZer n keep σp ]V)
  & \wk_n[\keep^n\mhyphen\cons]  & &
  :
  (\wk_n Z) [\keep^n (u \consu \sigma)] = Z [ \keep^n \sigma]
  \\
  % l-sub[]V : ∀ n x z σ
    % ((x [ n := z ]V) [ iZer n keep σ ]Z) = (x [ iZer (S n) keep σ ]V) [ n := (z [ σ ]Z) ]Z
   & [:=][\keep] && : Z [ n:= u][\keep^n \sigma] =  Z[\keep^{n+1}\,\sigma][n := u[\sigma]]
  \end{alignat*}
As particular cases for $n=0$, we get
\begin{alignat*}{5}
  & {}{\circ}{}\wkO & & : \sigma \circ (\wkO \tau) = \wkO (\sigma \circ \tau) \\
  & \wkO{}{\circ}{}, && : \wkO\,\sigma \circ (t \consu \tau ) = \sigma \circ \tau \\
  & [\wkO] && : t[\wkO\,\sigma] = \wk_0 (t[\sigma]) \\
  & \wk_0[\cons] && : (\wk_0 Z)[u \consu \sigma] = Z[\sigma] \\
  & [0:=][] && : Z [ 0:= u][ \sigma] =  Z[\keep\,\sigma][0 := u[\sigma]]
\end{alignat*}
Finally, we show the following:
\begin{alignat*}{5}
  & [][] && : Z[\sigma][\tau] = Z[\sigma\circ\tau]
  \\
  & \ass && : (\sigma\circ \delta)\circ\tau = \sigma\circ (\delta\circ\tau)
  \end{alignat*}
We defer laws for identity substitutions to after the definition of the typing
judgments, as the proofs require that some inputs are well-typed.

  % The two ways yield provably equal definitions, but
  % The advantage of the second
  % one in a type theory with UIP and function extensionality is that we get
  % definitional equalities such as $(t\,\appu\,u)[\sigma]=\app\,t[\sigma]\,u[\sigma]$.

  % \\
  % & \blank[\blank := \blank] && : \N\ra\N\ra\Tmu\ra\Tmu


  \subsubsection{Typing judgments}
  \label{sec:typing_judgments}
  The typing judgments are defined as the following inductive datatype indexed over the
  untyped syntax:
\begin{alignat*}{5}
  & \rlap{(1) Substitution calculus} \\[0.5em]
  & \blank \vdash && : \Conu\ra \Set \\
  & \blank \vdash \blank  && : \Conu\ra \Tyu\ra\Set \\
  & \blank \vdash \blank \in \blank  && : \Conu\ra \Tmu\ra \Tyu\ra \Set \\
  & \blank \vdash \blank \invar \blank  && : \Conu\ra \N \ra \Tyu\ra \Set \\
  & \blank \vdash \blank \Rightarrow \blank  && : \Conu\ra \Subu \ra \Conu\ra \Set \\
  % & \Subpre  && : \Set \\
  & \emptyw && : \emptyu \vdash \\
  & \epsilonw && : \Gamma\vdash \epsilonu \Rightarrow \emptyu \\
  & \blank\extw\blank && : ( \Gamma\vdash )  \ra  (\Gamma\vdash A)  \ra
  \Gamma\extu A \vdash \\
  & \consw && :
    (\Delta \vdash) \ra
    (\Gamma\vdash \sigma \Rightarrow\Delta)\ra
    ( \Delta \vdash A) \ra
    ( \Gamma \vdash t \in A[\sigma]) \ra
    \Gamma \vdash t \consu \sigma \Rightarrow \Delta\extu A
   \\
  & \varw  && : (\Gamma \vdash n \invar A) \ra \Gamma \vdash \varu n \in A \\
  & \vzw  && : (\Gamma\vdash)\ra(\Gamma\vdash A)\ra\Gamma \extu  A \vdash 0 \invar \wku \, A \\
  & \vsw  && : (\Gamma\vdash)\ra(\Gamma\vdash A)\ra(\Gamma \vdash n \invar A) \ra (\Gamma \vdash B) \ra \Gamma \extu  B
  \vdash S\,n \invar \wku \, A \\
  & \rlap{(2) Sorts and operators} \\[0.5em]
  & \Uw && : (\Gamma \vdash)\ra \Gamma \vdash \Uu \\
  & \Elw && : (\Gamma \vdash)\ra (\Gamma \vdash a \in \Uu)\ra\Gamma \vdash \Elu\,a \\
  & \rlap{(3) Parameters} \\[0.5em]
  & \Piw && :
    (\Gamma \vdash)\ra (\Gamma \vdash a \in \Uu)\ra(\Gamma \extu
  \Elu\,a \vdash B)\ra\Gamma \vdash \Piu \, a \, B \\
  & \appw && :
    (\Gamma \vdash)\ra (\Gamma \vdash a \in \Uu)\ra(\Gamma \extu
    \Elu\,a \vdash B)
    \\
    & &&
    \ra(\Gamma \vdash t \in \Piu \, a \, B )
    \ra
    (\Gamma \vdash u \in \Elu\,a)
    \ra
    \Gamma \vdash t \appu u \in  B [0 := u] \\
  & \rlap{(4) Metatheoretic parameters} \\[0.5em]
  & \Pimw && :
    (T:\Set)\ra(A : T\ra \Tyu)\ra(\Gamma \vdash)\ra
    ((t : T)\ra\Gamma\vdash A\,t) \ra
    \Gamma \vdash \Pimu \,T\,A
    \\
    & \appmw  && :
    (T:\Set)\ra(A : T\ra \Tyu)\ra(\Gamma \vdash)\ra
    ((t : T)\ra\Gamma\vdash A\,t)
    \\
    & &&
    \ra(\Gamma \vdash t \in \Pimu \,T\,A)
    \ra (u : T) \ra \Gamma \vdash t\,\appmu\,u \in A\,u
    \\
  & \rlap{(5) Infinitary parameters} \\[0.5em]
  & \Piiw && :
    (T:\Set)\ra(A : T\ra \Tmu)\ra(\Gamma \vdash)\ra
    ((t : T)\ra\Gamma\vdash A\,t\in \Uu)
    \\ &&& \ra
    \Gamma \vdash \Pimu \,T\,A \in \Uu
  \\
  & \appiw && :
    (T:\Set)\ra(A : T\ra \Tmu)\ra(\Gamma \vdash)\ra
    ((t : T)\ra\Gamma\vdash A\,t\in\Uu)
    \\
    & &&
    \ra
    (\Gamma \vdash t \in \Piiu \,T\, A)
    \ra (u : T) \ra \Gamma \vdash t\,\appmu\,u \in A\,u
\end{alignat*}
There is possibility of redundancy in the arguments of the constructors. Here,
we are ``{paranoid}'', so that we get more inductive hypotheses when performing
recursion.

% The substitution part could be moved after the mutual definition of terms, types,
% and contexts.

\subsubsection{Weakening preserves typing}
\label{ss:weaken-typing}
We prove by mutual induction that typing judgments are stable under weakening,
for contexts, types, terms, and substitutions:
% wkTelw : ∀ {Γp}{Ap}(Aw : Γp ⊢ Ap)Δp (Δw : (Γp ^^ Δp) ⊢) → ((Γp ▶p Ap) ^^ wkTel Δp) ⊢
% liftTw : ∀ {Γp}{Ap}(Aw : Γp ⊢ Ap)Δp{Bp}(Bw : (Γp ^^ Δp) ⊢ Bp) → ((Γp ▶p Ap) ^^ wkTel Δp) ⊢ (liftT ∣ Δp ∣ Bp)
\begin{alignat*}{5}
  & \wf{\wkO} && : (\Gamma \vdash A)\ra(\Gamma \merge \Delta\vdash) \ra
  \Gamma \extu A \merge \wkO\, \Delta \vdash \\
  % liftV (S (n + p)) (liftV n q) ≡ liftV n (liftV (n + p) q)
  & \wf{\wk} && : (\Gamma \vdash A)\ra(\Gamma \merge \Delta\vdash B) \ra
  \Gamma \extu A \merge \wkO\,\Delta \vdash \wk_{\length{\Delta}}\, B  \\
  & \wf{\wk} && : (\Gamma \vdash A)\ra(\Gamma \merge \Delta\vdash t\in B) \ra
  \Gamma \extu A \merge \wkO\,\Delta \vdash \wk_{\length{\Delta}}\, t \in \wk_{\length{\Delta}}\,B  \\
  & \wf{\wkO} && : (\Gamma \vdash A)\ra(\Gamma \vdash \sigma
  \Rightarrow \Delta) \ra
  \Gamma \extu A \vdash \wkO\, \sigma \Rightarrow \Delta
  \end{alignat*}
\subsubsection{Substitution preserves typing}
  First, we show that judgments are stable under substitution.
\begin{alignat*}{5}
  % Tyw[] : ∀ {Γp}{Ap}(Aw : Γp ⊢ Ap) {Δp}(Δw : Δp ⊢){σp}(σw :  Δp ⊢ σp ⇒ Γp) → Δp ⊢ (Ap [ σp ]T)
  & \wf{[]} && : (\Gamma \vdash)\ra(\Delta \vdash A)\ra
  (\Gamma \vdash \sigma \Rightarrow \Delta) \ra
  \Gamma \vdash A [ \sigma ]
  \\
  & \wf{[]} && : (\Gamma \vdash)\ra(\Delta \vdash t \in A)\ra
  (\Gamma \vdash \sigma \Rightarrow \Delta) \ra
  \Gamma \vdash t [\sigma] \in A [ \sigma ]
  \\
  & \wf{[]} && : (\Delta \vdash x \invar A)\ra
  (\Gamma \vdash \sigma \Rightarrow \Delta) \ra
  \Gamma \vdash x [\sigma] \in A [ \sigma ]
  % ∘w : ∀ {Γ} {Δ σ} (σw :  Δ ⊢ σ ⇒ Γ)
  %  {Y}(Yw : Y ⊢) {δ} (δw :  Y ⊢ δ ⇒ Δ) →
  %  Y ⊢  (σ ∘p δ) ⇒ Γ
  \\
  & \wf{{\circ}} && :
  (\Gamma \vdash) \ra
  (\Gamma \vdash \sigma \Rightarrow \Delta) \ra
  (\Delta \vdash \tau \Rightarrow E) \ra
  \Gamma \vdash \tau \circ \sigma \Rightarrow E
  % keepw : ∀ {Γp}(Γw : Γp ⊢){Δp}(Δw : Δp ⊢){σp}(σw :  Γp ⊢ σp ⇒ Δp) {Ap}(Aw : Δp ⊢ Ap ∈ Up ) → (Γp ▶p (Elp Ap [ σp ]T )) ⊢ (keep σp) ⇒ (Δp ▶p Elp Ap)
  % & \wf{keep-\El} && : (\Gamma \vdash)\ra(\Delta \vdash A)\ra
  % (\Gamma \vdash \sigma \Rightarrow \Delta) \ra
  % \Gamma \vdash A [ \sigma ]
  % \\
  \end{alignat*}
\subsubsection{Laws for identity substitutions}
We show category and functor laws involving identity substitution, for
well-formed types, terms and substitutions.
\begin{alignat*}{5}
  % [idp]V : ∀ {Γ}{A}{x}(xw : Γ ⊢ x ∈v A) → (x [ idp ∣ Γ ∣ ]V) ≡ V x
  & [\idu] && : (\Gamma \vdash A)\ra A [ \idu\,\Gamma]  \\
  & [\idu] && : (\Gamma \vdash x \invar A)\ra x [ \idu\,\Gamma] = V x \\
  & [\idu] && : (\Gamma \vdash t \in A)\ra t [ \idu\,\Gamma] = t \\
  & \idru && : (\Gamma \vdash \sigma \Rightarrow\Delta)\ra \sigma \circ \idu\,\Gamma = \sigma \\
  & \idlu && : (\Gamma \vdash \sigma \Rightarrow\Delta)\ra \idu\,\Delta\circ \sigma = \sigma
  \end{alignat*}
Finally, we show that the identity substitution itself is well typed:
  \begin{alignat*}{5}
  & \idw && : (\Gamma \vdash)\ra \Gamma \vdash \idu\,\Gamma \Rightarrow \Gamma
  \end{alignat*}



\subsubsection{Proof irrelevance and unicity of typing}
\label{ss:uniq-typing-types}
A type is a proposition, or proof-irrelevant, if it has at most one inhabitant.
  \[
    \isaprop\,T := (a : T) \ra (a' : T) \ra a = a'
  \]
We show that each of the typing judgments is unique in the
following sense:

\todo{Prettify table.}
\begin{align*}
    \isp{\Conw}
  : \isaprop\, (\Gamma\vdash)
 & &
    \isp{\Tmw}
  : \isaprop\, (\Gamma\vdash t \in A)
    \\
    \isp{\Tyw}
  : \isaprop\, (\Gamma\vdash A)
    &&
    \isp{\wf\Var}
  : \isaprop\, (\Gamma\vdash x \invar A)
  \\
  &
        \isp{\wf\Sub}
  : \isaprop\, (\Gamma\vdash \sigma \Rightarrow \Delta)
  \end{align*}
We also show unicity of typing:
\begin{alignat*}{5}
  &
  \Tmw{=}\Ty & &:
  (\Gamma \vdash t \in A) \ra
  (\Gamma \vdash t \in B) \ra A = B
  \\
  &
  \wf\Var{=}\Ty & &:
  (\Gamma \vdash x \invar A) \ra
  (\Gamma \vdash x \invar B) \ra A = B
  \end{alignat*}
Let us consider for instance the application constructor $\appw$: for a codomain
type $B$ it yields an overall type $C=B[0 := u]$ for an application. Even
if $C$ is known a priori, there may be another $B$ for which $B[0 := u] = C$,
possibly leading to many proofs that $t\appu u$ has type $C$. Unicity of typing
solves this issue, as $B$ is then uniquely determined by the type $\Piu\,A\,B$
of $t$.

%% Actually, the application and successor cases require to show uniqueness of
%% types in a given context, before.
%% Let us consider for instance the application constructor $\appw$: it provides a
%% type $B$ such that the final type is $C=B[0 := u]$. Even if $C$ is known a
%% priori, there may be another $B$ for which $B[0 := u] = C$, possibly leading to
%% many proofs that $t\appu u$ has type $C$. Uniqueness of types
%% solves this issue, as $B$ is then uniquely determined by the type $\Piu\,A\,B$ of $t$.


% \subsubsection{UIP and functional extensionality}
 % , which is not applyable without
 % functional extensionality.

 \subsubsection{Syntactic model}
 The syntactic model is obtained by packing the untyped syntax with the typing
 judgments:
% % \subsection{QIIT model}
% Then, we show that they are stable by weakening and substitution.
% Packing the untyped syntax with well-formed typed judgments yields
% a model $S$ of the QIIT. Let us give the most important components:
\begin{alignat*}{5}
 & \syn\Con && := \sum_\Gamma \Gamma\vdash
 \\
 & \syn\Ty \,(\Gamma,\wf\Gamma)&& := \sum_A \Gamma\vdash A
 \\
 & \syn\Tm \,(\Gamma,\wf\Gamma)(A,\wf A)&& := \sum_t \Gamma\vdash t \in A
 \\
 & \syn\Sub \,(\Gamma,\wf\Gamma)(\Delta,\wf \Delta)&& := \sum_\sigma \Gamma\vdash \sigma \Rightarrow \Delta
\end{alignat*}
The other fields are given straightforwardly.  Regarding the equations, it is
enough to prove them only for the untyped syntactic part: as we argued in
Section~\ref{ss:uniq-typing-types}, the proofs of typing judgments are
automatically equal.

None of the constructions in this section use UIP. Functional extensionality is
necessary because the metatheoretic or infinitary (untyped) $\Pi$ takes a
metatheoretic function as an argument. An example induction step that uses it
is in the type preservation proof for identity substitutions (this is an
equation satisfied by a model of the QIIT), in particular in the case
$(\Pim\,T\, A)[\id]=\Pim\,T\,A$. Indeed, the left hand side of this equation is
equal to $\Pim\,T\,(\lambda t.(A\,t)[\id])$ by definition, whereas the induction
hypothesis states that $(t:T)\ra (A\,t)[\id]=A\,t$.

\subsection{Relating the Syntax to a Model}
It remains to show that the constructed syntactic model is initial. To achieve
this, we first define a relation between the syntactic model and an arbitrary
model, then show that the relation is functional, which lets us extract a
homomorphism from the relation.

This approach is an alternative version of Streicher's method for interpreting
preterms in an arbitrary model\cite{streichersemantics}. Streicher first defines
a family of partial maps from the presyntax to a model, then shows that the maps
are total on well-formed input. We have found that our approach is significantly
easier to formalise. Too see why, note that the right notion of partial map in
type theory, which does not presume decidable definedness, is fairly
heavyweight:
\[
  \mathsf{PartialMap}\,A\,B := A\ra (P : \mathsf{hProp})\times(P \ra B)
\]
Here $\mathsf{hProp}$ denotes a type which is propositional. In the above
definition, we notice an opportunity for converting a fibered definition of a
type family into an indexed one; if we drop the propositionality for $P$ for the
time being, we may equivalently return a family indexed over $B$, which is
exactly just a relation $A\ra B\ra\Set$. Then, in our approach, we recover
uniqueness of $P$ through the functionality requirement on the $A\ra B\ra\Set$
relation, and totality by already assuming well-formedness in the syntax. In type
theory, using indexed families instead of display maps is a common convenience,
since the former are natively supported in type theory, while the latter require
carrying around auxiliary propositional equalities.

\subsubsection{The functional relation}

Given a model $M$ of the QIIT, we define the functional relation satisfied by
the initial morphism $\rec : S\to M$ by recursion on the typing judgments.
% As these judgments are propositions, we will sometimes
If $\Gamma$ is a context in $S$ and $\model{\Gamma}$ is a semantic context
(i.e.\ a context of the model $M$), we want to define a type
$\Gamma\sim \model{\Gamma}$ equivalent to $\rec\,\,\Gamma=\model{\Gamma}$. Of
course, at this stage, $\rec$ is not available yet since the point of
defining this relation is to construct $\rec$ in the end.

For a type $A$ in a context $\Gamma$, we want to define a relation
$A\sim \model{A}$ that is equivalent to $\rec\,\,A=\model{A}$.
% where $\model{A}$ is a
% semantic type in a semantic context $\model{\Gamma}$.
For this equality to make sense, the semantic type $\model{A}$ must live
in the semantic context $\rec\,\,\Gamma$. But again, $\rec$ is not
yet available at this stage. Exploiting the expected equivalence between
$\Gamma\sim\model\Gamma$ and $\rec\,\,\Gamma=\model\Gamma$, we may consider defining $A\sim\model{A}$ under the
hypotheses that $\model{A}$ lies in a semantics context $\model\Gamma$ which is
related to $\Gamma$. Then, the type of the relation for types is
\[
  (\Gamma : \syn\Con)\ra (A : \syn\Ty\syn\Gamma) \ra
  (\model\Gamma : \model\Con)
  \ra
  (\Gamma \sim \model\Gamma)
  \ra
  (\model{A}:\model\Ty\model\Gamma)
  \ra
  \Set
\]
Note that the relation on contexts
must be defined mutually with the relation on types (see for example the case of
context extension), but here, the relation on contexts appears as the type of an
argument of the relation on types.
% We leave this possibility aside,
Our metatheory does not support this kind of recursive-recursive
definitions\footnote{And to our knowledge there is no established semantics for
it in existing literature.}, so we instead just remove the hypothesis
$\Gamma\sim\model\Gamma$ from the list of arguments.  We proceed similarly for
terms and substitutions. Actually, this removal is not without harm. For
example, consider relating the empty substitution
$\Gamma\vdash \epsilonu \Rightarrow \emptyu $ to a semantic substitution
$\model\sigma : \model\Sub\,\model\Gamma\,\model\Delta$. We would like to assert
that $\model\sigma$ equals the empty semantic substitution $\model\epsilon$, but
this is not possible because typechecking requires that $\model\Delta$ is the
empty semantic context. This is precisely what ensured the removed hypothesis
$\syn\cdot \sim \model\Delta$.  Our way out here is to state that $\model\sigma$
is related to the empty substitution if the target semantic context $\model\Delta$
is empty, and, acknowledging this equality, if $\model\sigma$ is the empty
substitution.
% The idea is that we will first prove that there is atmost one semantic type
% which relates to the syntactic one, and then later we will provide such a
% semantic type under the hypothesis that the contexts are related.

Let us mention another possible solution for avoiding recursion-recursion:
defining $A\sim\model{A}$ so that it is equivalent to $(e:\rec\,\Gamma
= \model{\Gamma})\times (\rec\,A = e\#\model{A})$.
% whereas the right hand side is of type $\model\Ty\model{\Gamma}$.
% For a substitution $\sigma$ between contexts $\Gamma$ and $\Delta$,
% a first idea consists in defining a relation $\sigma \sim_{\blank} \model{\sigma} : \Gamma
% \sim \model\Gamma \to \Set $ where $\model{A}$ is a semantic type in the
% semantic context $\model{\Gamma}$. We define the relation on types under the hypothesis
% that the contexts are already related.
% it is natural to define the relation with a semantic type $\model{A}$ in a
% semantic context $\model{\Gamma}$ such that it is equivalent to  $(\rec\,\Gamma = \model{\Gamma})\times (\rec\,A = \model{A})$ (note that the first equality is
% required for the second one to be well-typed).
% The discussion is similar for terms.
% Then, the ultimate goal is to prove that
% $\sum_{\model{\Gamma}}\Gamma\sim\model{\Gamma}$ and
% $\sum_{\model{\Gamma}}({\model{A}:\model{\Ty}\,\model{\Gamma}})\times(A\sim\model{A})$
% are contractible, i.e., have a unique inhabitant.
%The first step consists in showing that these types are propositions.
In contrast to this, our approach
% Actually, we take a different approach for the relation on types
% (and terms) which
yields a more concise definition of the relation.
For example, in the case of the universe, this would lead
to the definition
  $  \Uw\wf{\Gamma} \sim \model{A} := (\wf{\Gamma}\sim\model{\Gamma}) \times (\model{A} = \model{\U})$,
  instead of
  our definition
  $  \Uw\wf{\Gamma} \sim \model{A} := (\model{A} = \model{\U})$.
% Recall that our adapted goal, for types, is to prove that
% $\sum_{\model{A}}A\sim\model{A}$ is a proposition, and
% is inhabited if $\Gamma \sim \model{\Gamma}$ is.
%  This means that in the definition of the relation, we assume
% that contexts are already related, so that we don't need to enforce them to be,
% as it is the case in the original approach.
% We give the two versions of the universe
% case below, to explain the differences.


% Many of the terms below are well-typed because the target model satisfies some
% equalities that are reflected as definitional equalities.
% In the formalization, we even postulate rewrite rules for some of the equations that the
% model $M$ should satisfy (otherwise, we are faced with too many hellish transports).
% This is, in some sense, another place where UIP is needed, as it is known that
% extensional type theory can be translated in intensional type theory using UIP
% and functional extensionality. This requirement can be qualified: we
% could say that we only claim to eliminate to models that definitionally
% satisfies the equalities that we enforce, although we haven't checked that this is enough to
% construct any IIT from the universal one (and anyway, UIP and functional
% extensionality are needed to construct any IIT from the universal one).

Here we provide the definition of the relation by recursion on the typing judgments.
In the definitions, we abbreviate $\relT{\wf{A}}{\model\Gamma}{\model{A}}$ by
$\wf{A}\sim\model{A}$ when $\model{\Gamma}$ can be inferred, and similarly for
terms and substitutions.
\begin{alignat*}{5}
  & \rlap{(1) Substitution calculus} \\[0.5em]
  & \blank \sim{ \blank} && :  \Gamma \vdash \, \ra \model{\Con} \ra \Set \\
  & \relT{\blank}{\model{\Gamma}}{\blank} && :  \Gamma \vdash A \, \ra \model{\Ty}\,\model{\Gamma} \ra \Set \\
  & \relt{\blank}{\model{\Gamma}}{\model{A}}{\blank} && :  \Gamma \vdash t \in A \, \ra \model{\Tm}\,\model{\Gamma}\,\model{A} \ra \Set \\
  & \relV{\blank}{\model{\Gamma}}{\model{A}}{\blank}&& :  \Gamma \vdash x \invar A \, \ra \model{\Tm}\,\model{\Gamma}\,\model{A} \ra \Set \\
  & \relS{\blank}{\model{\Gamma}}{\model{\Delta}}{ \blank} && :  \Gamma \vdash \sigma \Rightarrow \Delta \, \ra \model{\Sub}\,\model{\Gamma}\,\model{\Delta} \ra \Set \\
  \\
  & \emptyw\sim \model{\Gamma} && := \model{\Gamma}=\model{\cdot} \\
  & \relS{\epsilonw}{\model{\Gamma}}{\model{E}}{\model{\delta}}
  % (  \vdash \model{\delta}\Rightarrow \model{E})
  &&
 := (e_E : \model{E} = \model{\cdot})\times (\model{\delta} = e_E \#
 \model{\epsilon})
  \\
  & (\wf{\Gamma}\extw \wf{A})\sim \model{\Delta} &&
   :=
    \sum_{\model{\Gamma}} (\wf{\Gamma}\sim\model{\Gamma}) \times
    \sum_{\model{A}} (\wf{A}\sim\model{A}) \times
    \\
    & && \qquad
    (\model{\Delta} = \model{\Gamma} \model{\ext} \model{A})
    \\
    &
    \relS{(\consw \wf{\Delta}\wf{\sigma}\wf{A}\wf{t})}{\model{\Gamma}}{\model{E}}{\model{\delta}}
    % (\consw \wf{\Delta}\wf{\sigma}\wf{A}\wf{t})\sim
    % \\
    % & \qquad
    % ( \model{\Gamma} \vdash \model{\delta}\Rightarrow \model{E})
    &&
   :=
    \sum_{\model{\Delta}} (\wf{\Delta}\sim\model{\Delta}) \times
    \sum_{\model{\sigma}} (\wf{\sigma}\sim\model{\sigma}) \times
    \\
    & && \qquad
    \sum_{\model{A}} (\wf{A}\sim\model{A}) \times
    \sum_{\model{t}} (\wf{t}\sim\model{t}) \times
    \\
    & && \qquad
    (e_E : \model{E} = \model{\Delta} \model{\ext} \model{A}) \times
    \\
    & && \qquad
    (\delta = e_E \# \model\sigma \model{\cons} \model{t} )
    \\
  & \varw\,\wf{x} \sim \model{t}
   && := \wf{x}\sim \model{t} \\
   & \relV{\vzw\wf{\Gamma}\wf{A}}{\model{\Delta}}{\model{B}}{\model{t}}
  %  \vzw\wf{\Gamma}\wf{A}
  % \sim \\
  % & \qquad (\model{\Delta}\vdash \model{t}\in \model{B} )
   && :=
    \sum_{\model{\Gamma}} (\wf{\Gamma}\sim\model{\Gamma}) \times
    \sum_{\model{A}} (\wf{A}\sim\model{A}) \times \\
    & &&
    \qquad
  (e_\Delta : \model{\Delta} = \model{\Gamma} \model{\ext} \model{A})
     \times
    \\
    & && \qquad
     (e_B : \model{B} = e_\Delta \# \model{\wk}\,\model{A}) \times
     % \\
     % & && \qquad
     (\model{t} = e_\Delta,e_B \# \model{\vz})
  \\
  &
   \relV{\vsw \wf{\Gamma} \wf{A} \wf{n} \wf{B}}{\model\Delta}{\model{C}}{\model{t}}
  % \vsw \wf{\Gamma} \wf{A} \wf{n} \wf{B} \sim
  % \\
  % & \qquad
  %    (\model{\Delta}\vdash \model{t}\in \model{C} )
   && :=
    \sum_{\model{\Gamma}} (\wf{\Gamma}\sim\model{\Gamma}) \times
    \sum_{\model{A}} (\wf{A}\sim\model{A}) \times
    \\
    & &&\qquad
    \sum_{\model{B}} (\wf{B}\sim\model{B}) \times
    \sum_{\model{n}} (\wf{n}\sim\model{n}) \times
    \\
    & &&
    \qquad
  (e_\Delta : \model{\Delta} = \model{\Gamma} \model{\ext} \model{B})
     \times
    \\
    & && \qquad
     (e_C : \model{C} = e_\Delta \# \model{\wk}\,\model{A}) \times
     % \\
     % & && \qquad
     (\model{t} = e_\Delta,e_C \# \model{\vs} \, \model{n})
  \\
  & \rlap{(2) Sorts and operators} \\[0.5em]
  & \Uw \wf{\Gamma} \wf{A} \sim \model{A} &&
   := \model{A} = \model{\U}
  \\
  & \Elw \wf{\Gamma} \wf{a} \sim \model{A}
  && :=
  \sum_{\model{a}} (\wf{a}\sim  \model{a}) \times
    (\model{A} = \model{\El}\,\model{a})
  \\
  & \rlap{(3) Parameters} \\[0.5em]
  & \Piw \wf{\Gamma} \wf{a} \wf{B} \sim \model{C} &&
   :=
      \sum_{\model{a}} (\wf{a}\sim\model{a})
      \times
      \sum_{\model{B}} (\wf{B}\sim\model{B})
      \\
      &&& \qquad \times (\model{C}= \model{\Pi}\,\model{a}\,\model{B})
  \\
  &
  \relt{\appw \wf{\Gamma} \wf{a} \wf{B} \wf{t} \wf{u}}{\model{\Gamma}}{\model{C}}{\model{x}}  &&
  % & \appw \wf{\Gamma} \wf{a} \wf{B} \wf{t} \wf{u} \sim \\
  % & \qquad (\model{\Gamma}\vdash x\in \model{C})  &&
    :=
      \sum_{\model{a}} (\wf{a}\sim\model{a})
      \times
      \sum_{\model{B}} (\wf{B}\sim\model{B})
      \times
      \\
      & && \qquad
      \sum_{\model{t}} (\wf{t}\sim\model{t})
      \times
      \sum_{\model{u}} (\wf{u}\sim\model{u})
      \times
      \\
      & &&
     \qquad  (e_C : \model{C} = \model{B}\model{[0 := \model{u}]})
      \times
      \\
      & &&
      \qquad
      (\model{x} = e_C \# \model{t} \model{\oldapp}\model{u})
    \\
  & \rlap{(4) Metatheoretic parameters} \\[0.5em]
  & \Pimw T\,A\,\wf{\Gamma}\wf{A} \sim \model{B} &&
    :=
      \sum_{\model{A}} ((t : T) \ra \wf{A}\sim\model{A}\, t)
      \times
      (\model{B} = \model{\Pim}\,T\,\model{A})
    \\
    & \relt{\appmw T\,A\,\wf{\Gamma}\wf{A} \wf{t} u}{\model{\Gamma}}{\model{B}}{\model{x}}
    % & \appmw T\,A\,\wf{\Gamma}\wf{A} \wf{t} u \sim
    % \\
    % & \qquad
    % (\model{\Gamma}\vdash x\in \model{B})
     &&
     :=
      \sum_{\model{A}} ((t : T) \ra \wf{A}\sim\model{A}\, t)
      \times
      \sum_{\model{t}} (\wf{t}\sim\model{t})
      \times
      \\ & &&
      \qquad
      (e_B : \model{B} = \model{\Pim}\,T\,\model{A})
      \times
      (\model{x} = e_B \# \model{t}\model{\hat{\oldapp}}u)
    \\
  & \rlap{(5) Infinitary parameters} \\[0.5em]
    & \Piiw T\,A\,\wf{\Gamma}\wf{A} \sim \model{B} &&
    :=
      \sum_{\model{A}} ((t : T) \ra \wf{A}\sim\model{A}\, t)
      \times
      (\model{B} = \model{\Pii}\,T\,\model{A})
    \\
    & \relt{\appiw T\,A\,\wf{\Gamma}\wf{A} \wf{t} u}{\model{\Gamma}}{\model{B}}{\model{x}}
    % & \appiw T\,A\,\wf{\Gamma}\wf{A} \wf{t} u \sim
    % \\
    % & \qquad
    % (\model{\Gamma}\vdash x\in \model{B})
     &&
     :=
      \sum_{\model{A}} ((t : T) \ra \wf{A}\sim\model{A}\, t)
      \times
      \sum_{\model{t}} (\wf{t}\sim\model{t})
      \times
      \\ & &&
      \qquad
      (e_B : \model{B} = \model{\Pii}\,T\,\model{A})
      \times
      (\model{x} = e_B \# \model{t}\model{\tilde{\oldapp}}u)
\end{alignat*}

% As discussed above, when writing the definition of the type components, we assume that the input semantic context is already
% related to the typing judgment of the syntactic context.
% The first version
% of the relation that we suggested at the beginning of the section
% would rather enforce them to be related.
% In the case of $\U$, this would lead
% to the definition
%   $  \Uw\wf{\Gamma} \sim \model{A} := (\wf{\Gamma}\sim\model{\Gamma}) \times (\model{A} = \model{\U})$,
%   instead of
%   the current definition
%   $  \Uw\wf{\Gamma} \sim \model{A} := (\model{A} = \model{\U})$.
%   Our choice makes the definitions more concise, and similarly
%  in the definition of the term components we assume that the input semantic
%  context and type are already related to their associated well-formedness judgments.
 % However, for some fields, we cannot avoid the first approach.
  % Unfortunately, we need sometimes to require some equalities that are actually
  % redundant with this external assumption.
  %, although we know that these equalities are
  % already satisfied by our assumption.
  % As we argued before, in the  of empty substitution $\epsilon$: we require the equality
  % $(e_C : \model{E} = \model{\cdot})$, although
  % our claimed external assumption that $\model{E}$ is  related to the
  % canonical proof $\epsilonw$ of the typing judgment $\epsilon \vdash$ should imply
  % it.
% Let us comment the first variable case:
  % Another example is the first variable case, where we follow the first verbose
  % approach:
  % the relation gives a semantic context $\model\Gamma$ that must be related
  % to the syntactic $\Gamma$, and a semantic
  % type $\model{A}$ related to the syntactic $A$. The input semantic context is
  % then required to equal $\model{\Gamma}\model{\ext}\model{A}$.   As
  % $\blank \model{\ext}\blank$ is not guaranteed to be injective, these
  % relations are required to show that the relation is right unique.
Next, we prove that this relation is right unique.
Then, we show that the relation is stable under weakening and substitution.
  The last step consists of giving a related semantic counterpart to any
  well-typed context, type or term.
  Everything is done by induction on the typing judgments.
  \subsubsection{Right uniqueness}
  We show by recursion that the relation is right unique in the following sense:
  \begin{alignat*}{5}
    &
    \isp{\Sigma{\sim}}
    && : (\wf\Gamma : \Gamma \vdash ) \ra
    \isaprop\, (\sum_{\model{\Gamma}} \wf{\Gamma} \sim \model{\Gamma})
    \\
    &
    \isp{\Sigma{\sim}}
    && : (\wf A : \Gamma \vdash A) \ra
    \isaprop\, (\sum_{\model{A}} \wf{A} \sim \model{A})
    \\
    &
    \isp{\Sigma{\sim}}
    && : (\wf t : \Gamma \vdash t \in A) \ra
    \isaprop\, (\sum_{\model{t}} \wf{t} \sim \model{t})
    \\
    &
    \isp{\Sigma{\sim}}
    && : (\wf x : \Gamma \vdash x \invar A) \ra
    \isaprop\, (\sum_{\model{x}} \wf{x} \sim \model{x})
    \\
    &
    \isp{\Sigma{\sim}}
    && : (\wf \sigma : \Gamma \vdash \sigma \Rightarrow \Delta) \ra
    \isaprop\, (\sum_{\model{\sigma}} \wf{\sigma} \sim \model{\sigma})
  \end{alignat*}
  We mentionned that in order to avoid a recursive-recursive definition, we
  removed some hypotheses in the list of arguments of the relation. Such
  hypotheses are sometimes missed, for example in the case of the empty
  substitution, or in the case of variables, requiring us to state additional
  equalities.  % some redundancies that we could not avoid when defining % the
  relation, for example in the case of the empty substitution.  Because of
  this, % It is because of the redundancies which we mentionned above we need
  UIP to show that the types $\sum_{\model{\Gamma}}\Gamma\sim\model{\Gamma}$ and
  $\sum_{\model{A}}A\sim\model{A}$ are propositions.  One may believe that the
  use of UIP could be avoided by embracing the alternative verbose definition
  that we suggested before, expecting that
  $\sum_{\model{\Gamma}}\sum_{\model{A}}A\sim\model{A}$, rather than
  $\sum_{\model{A}}A\sim\model{A}$, is a proposition.  However, this not so
  obvious. For example, we were not able to define
  $\Elw\wf{\Gamma}\wf{a}\sim \model{A}$ in this fashion. In related work,
  Hugunin investigated constructing inductive-inductive types without
  UIP\cite{hugunin2019constructing}, and demonstrated that well-formedness
  predicates used in syntactic models can be subtly incompatible with UIP. Also,
  while Hugunin does not use UIP, he only shows a weak version of dependent
  elimination for the constructed IITs. Hence, the question whether IITs are
  reducible to inductive types in a UIP-free setting remains open.




%% in this fashion so that
%%   UIP can be avoided to prove this statement.


  % \todo[inline]{András: Hugunin's paper has an example (which is
  %    likely generalizable) that a notion of redundancy in
  %    well-formedness relations implies that UIP is required.}
  \subsubsection{Stability under weakening}
  % Let us argue that it is necessary to show s
  Stability of the relation under
  weakening must be proved before stability under substitution.
  Indeed, in the proof of stability under substitution, the $\Pi$ case
  requires to show that $\Pi \,A[\sigma] \,B[\keep\,\sigma]$ is related to
  $\model{\Pi}\,\model{A}\model{[\sigma]}
  \model{A}\model{[\model{\keep}\,\sigma]}$.
  We would like to apply the induction hypothesis, so we need to show that
  $\keep\,\sigma=\varu\,0\consu\wkO\,\sigma$ is related to
  $\model{\keep}\,\model{\sigma}$, knowing that $\sigma$ is
  related to $\model{\sigma}$.
  As $\keep\,\sigma=\varu 0\consu \wkO\,\sigma$, we are left with showing that
  $\wkO\,\sigma=\sigma\circ\wk$ (where $\wk=\wkO \id$)
  relates to its semantic counterpart.

%   {-

% Suppose that Γ ^^ Δ ⊢ and Γ ⊢ E
% The following function computes both Γ ▶ E ^^ wk_E Δ and a substitution
% from this context to Γ ^^ Δ.
% I don't see how to avoid constructing these two components simultaneously

% -}
% ΣwkTel⇒ᵐ :
%   ∀ {Γ}{Γw :  Γ ⊢}(Γm : ∃ (Con~ Γw) )
%     (Em : M.Ty (₁ Γm))
%         {Δ }{Δw : Γ ^^ Δ ⊢}(Δm : ∃ (Con~ Δw)) →
        % ∃ λ T → M.Sub T (₁ Δm)


  To do that, we show that $\wkO$ preserves the relation, for types and terms.
  This requires to generalise a bit and show that $\wk_n$ preserves the relation,
  as $\wk_0(\Pi\,A\,B)=\Pi\,(\wk_0\,A)(\wk_1\,B)$.
  But remember that $\wk_n$ performs a weakening in the middle of a context, so
  we first define the semantic counterpart of this:
\begin{alignat*}{5}
  & \model{\Sigma\wkO{\Rightarrow}}  && :
   % & && \qquad
  (\wf{\Gamma} : \Gamma \vdash) \ra
  (\wf\Gamma \sim \model{\Gamma}) \ra
  \\
  & && \qquad
  (\wf{\Delta} : \Gamma\merge\Delta \vdash) \ra
  (\wf\Delta \sim \model{\Delta}) \ra
  \\ &&& \qquad
  (\model{A} : \model\Ty\model\Gamma)\ra
  (\model{\Delta'} : \model{\Con}) \times (\model{\Sub}\model{\Delta'}{\model{\Delta}})
\end{alignat*}
Here, $\model{\Delta'}$ should be thought of as the context $\model\Delta$ where
the weakening has happened in the middle of the context, by inserting the type
$\model{A}$ after the prefix $\model{\Gamma}$. Indeed, we expect that
$\model{\Gamma}$ is a prefix of $\model{\Delta}$, as $\model{\Gamma}$ relates to
$\Gamma$ and $\model{\Delta}$ to $\Gamma\merge\Delta$.
% $\wf{\Gamma}\sim\model\Gamma$
% and $\wf\Delta\sim\model\Delta$, and $\Gamma$ is a prefix of $\Gamma\merge\Delta$.
The substitution from the weakened context to the original one must
be computed at the same time otherwise the recursion hypothesis is not strong enough.
Then, we seperate the two components under the same (implicit) hypotheses:
\begin{alignat*}{5}
  & \model{\wkO}\,\model{A}\,\model\Delta  && :
  % (\model{A} : \model\Ty\model\Gamma)\ra
  % (\wf{\Gamma} : \Gamma \vdash) \ra
  % (\wf{\Delta} : \Gamma\merge\Delta \vdash) \ra
  % \\
  % & && \qquad
  % (\wf\Gamma \sim \model{\Gamma}) \ra
  % (\wf\Delta \sim \model{\Delta}) \ra
  % \\ &&& \qquad
   \model{\Con}
   \\
  & \model{\wk{\Rightarrow}}\,\model{A}\,\model\Delta  && :
  % (\model{A} : \model\Ty\model\Gamma)\ra
  % (\wf{\Gamma} : \Gamma \vdash) \ra
  % (\wf{\Delta} : \Gamma\merge\Delta \vdash) \ra
  % \\
  % & && \qquad
  % (\wf\Gamma \sim \model{\Gamma}) \ra
  % (\wf\Delta \sim \model{\Delta}) \ra
  % \\ &&& \qquad
   \model{\Sub}(\model{\wkO}\model{A}\,\model\Delta)\model\Delta
\end{alignat*}
Note that if recursion-recursion is available in the metatheory, $\model\wkO$
and $\wk\model{\Rightarrow}$ can be defined directly without introducing this
intermediate $\model{\Sigma\wkO\Rightarrow}$.


Now, we are ready to prove by mutual recursion on well-typed judgments that
weakening preserves typing. The following statements are all under the
hypotheses
  $(\wf{\Gamma} : \Gamma \vdash)$,
  $(\wf\Gamma \sim \model{\Gamma})$,
  $(\wf{\Delta} : \Gamma\merge\Delta \vdash)$,
  $(\wf\Delta \sim \model{\Delta})$,
  $(\wf{A} : \Gamma \vdash A)$,
  and
  $(\wf{A} \sim \model{A})$.
  % , except the last one about weakening substitutions,
  % which do not require that $\model\Delta$ is related to any well-formed context.
\begin{alignat*}{5}
  & \wkO{\sim}  &&
   :
  % (\wf{\Gamma} : \Gamma \vdash) \ra
  % (\wf\Gamma \sim \model{\Gamma}) \ra
  % \\
  %  & && \qquad
  % (\wf{\Delta} : \Gamma\merge\Delta \vdash) \ra
  % (\wf\Delta \sim \model{\Delta}) \ra
  % \\
  % & && \qquad
  % (\wf{A} : \Gamma \vdash A) \ra
  % (\wf{A} \sim \model{A}) \ra
  % \\
  % & && \qquad
  \wf{\wkO}\,\wf{A}\,\wf{\Delta}\sim\model{\wkO}\model{A}\model{\Delta}
  \\
  % wk
  & \wk{\sim} && :
  % (\wf{\Gamma} : \Gamma \vdash) \ra
  % (\wf\Gamma \sim \model{\Gamma}) \ra
  % \\
  %  & && \qquad
  % (\wf{\Delta} : \Gamma\merge\Delta \vdash) \ra
  % (\wf\Delta \sim \model{\Delta}) \ra
  % \\
  % & && \qquad
  % (\wf{A} : \Gamma \vdash A) \ra
  % (\wf{A} \sim \model{A}) \ra
  % \\
  % &&& \qquad
  (\wf{T} : \Gamma\merge\Delta \vdash T) \ra
  (\wf{T} \sim \model{T}) \ra
  % \\ &&& \qquad
  \wf{\wk}\,\wf{A}\,\wf{T}\sim\model{T}\model{[\model{\wkO{\Rightarrow}}\model{A}\model{\Delta}]}
  \\
    % wk
  & \wk{\sim} && :
  % (\wf{\Gamma} : \Gamma \vdash) \ra
  % (\wf\Gamma \sim \model{\Gamma}) \ra
  % \\
  %  & && \qquad
  % (\wf{\Delta} : \Gamma\merge\Delta \vdash) \ra
  % (\wf\Delta \sim \model{\Delta}) \ra
  % \\
  % & && \qquad
  % (\wf{A} : \Gamma \vdash A) \ra
  % (\wf{A} \sim \model{A}) \ra
  % \\
  % &&& \qquad
  (\wf{t} : \Gamma\merge\Delta \vdash t\in T) \ra
  (\wf{t} \sim \model{t}) \ra
  % \\ &&& \qquad
  \wf{\wk}\,\wf{A}\,\wf{t}\sim\model{t}\model{[\model{\wkO{\Rightarrow}}\model{A}\model{\Delta}]}
  \\
    % wk
  & \wk{\sim} && :
  % (\wf{\Gamma} : \Gamma \vdash) \ra
  % (\wf\Gamma \sim \model{\Gamma}) \ra
  % \\
  %  & && \qquad
  % (\wf{\Delta} : \Gamma\merge\Delta \vdash) \ra
  % (\wf\Delta \sim \model{\Delta}) \ra
  % \\
  % & && \qquad
  % (\wf{A} : \Gamma \vdash A) \ra
  % (\wf{A} \sim \model{A}) \ra
  % \\
  % &&& \qquad
  (\wf{x} : \Gamma\merge\Delta \vdash t\invar T) \ra
  (\wf{x} \sim \model{x}) \ra
  % \\ &&& \qquad
  \wf{\wk}\,\wf{A}\,\wf{x}\sim\model{x}\model{[\model{\wkO{\Rightarrow}}\model{A}\model{\Delta}]}
  % \\ &&& \qquad
  % \wf{\wk}\,\wf{A}\,\wf{x}\sim\model{x}\model{[\model{\wkO{\Rightarrow}}\model{A}\model{\Delta}]}
\end{alignat*}
Then we deduce, still by induction, that weakening of substitution preserves the
relation:
\begin{alignat*}{5}
    % wk
  & \wkO{\sim} && :
  (\wf{\Gamma} : \Gamma \vdash) \ra
  (\wf\Gamma \sim \model{\Gamma}) \ra
  % \\
  %  & && \qquad
  % (\wf{\Delta} : \Gamma\merge\Delta \vdash) \ra
  % (\wf\Delta \sim \model{\Delta}) \ra
  % \\
  % & && \qquad
  (\wf{A} : \Gamma \vdash A) \ra
  (\wf{A} \sim \model{A}) \ra
  \\
  &&& \qquad
  (\wf{\sigma} : \Gamma\vdash \sigma \Rightarrow \Delta) \ra
  (\wf{\sigma} \sim \model{\sigma}) \ra
  % \\
  % &&& \qquad
  (\wf{\wkO}\wf{A}\wf\sigma \sim \model{\sigma}\model{\circ}\model{\wk})
  \end{alignat*}



%   But to give a precise meaning to the statement that $\wk_n$ (which weakens at
%   the middle of context) preserve the
%   relation, we define (inductively) the notion of semantic telescopes.
%   First, we define the notion of being a prefix:
% \begin{alignat*}{5}
%   & \blank\leq\blank  && : \model\Con\ra \model\Con\ra\Set \\
%   & {\leq}\cdot  && : \model{\Gamma} \leq \model{\Gamma} \\
%   & \blank{\leq}{\ext}\blank  && : \model{\Gamma} \leq \model{\Delta} \ra (A :
%   \model{\Ty}\Delta) \ra \model{\Gamma}\leq\model{\Delta}\model{\ext}\model{A}
% \end{alignat*}
% Now, a telescope on a semantic context $\model{\Gamma}$ is a semantic context
% $\model{\Delta}$ such that $\model{\Gamma}\leq \model{\Delta}$.

% \begin{alignat*}{5}
%   & \Tel\,\model{\Gamma}  && := (\model{\Delta} : \model{\Con})\times (\model{\Gamma}\leq \model{\Delta})
% \end{alignat*}
% Similarly to the untyped case, we define the merging of a context and a telescope by recursion on the telescope:
% \begin{alignat*}{5}
%   & \blank\model{\merge}\blank  && := (\model{\Gamma} : \model{\Con}) \ra
%   (\model{\Delta} : \Tel\,\model\Gamma) \ra \model{\Con} \\
%   & \model\Gamma \merge (\model\Gamma,{\leq}\cdot) && :=  \model\Gamma \\
%   & \model\Gamma \merge (\model\Delta\model{\ext}\model{A}, \Delta_{\leq} {\leq}{\ext} \model{A}) && :=  (\model\Gamma \model\merge \model\Delta)\model\ext \model{A}\\
% \end{alignat*}
% We then define a relevant relation between syntactic telescopes and semantic telescopes.
% Untyped syntactic telescopes are modeled by untyped contexts, because they are
% list of types.
% A syntactic telescope $\Delta$ is then well formed in a context $\Gamma$ if
% $\Gamma\merge\Delta$ is well formed.
% The relation is defined by recursion on the untyped syntactic telescope:
% \begin{alignat*}{5}
%   & \blank\sim\blank  && := ( \Gamma \merge \Delta \vdash) \ra (\model\Gamma\leq\model\Delta)
%   \ra \Set \\
%   & (\wf\Gamma : \Gamma \merge \emptyu \vdash)\sim\model\Delta  && :=
%   \model\Delta =  {\leq}\cdot\\
%   & (\wf\Delta \extw \wf{A} : \Gamma \merge (\Delta \extu A) \vdash)\sim\model{E}  && :=
%   \sum_{\model\Delta} (\wf\Delta\sim\model\Delta)
%   \times
%   \sum_{\model A} (\wf{A}\sim\model{A}) \times
%   \\
%   & && \qquad
%   \model{E} = \model\Delta {\leq}{\ext} \model{A}
% \end{alignat*}

\subsubsection{Stability under substitution}

 We want to prove that given any well-typed substitution $\sigma
: \Sub\,\Gamma\,\Delta$ and semantic contexts $\model{\Gamma}$ and
$\model{\Delta}$, respectively related to $\Gamma$ and $\Delta$, there exists a
semantic substitution which is related to $\sigma$.  In the extension case
$\Gamma\vdash \sigma \consu\,t\Rightarrow \Delta\,\extu\,A$, the induction
hypothesis provides $\model{\sigma}$, $\model{\Delta}$, $\model{A}$ related to
their syntactic counterpart. However, the premises of the induction hypothesis
for getting a relevant $\model{t}$ require showing that the type
$\model{A}\model{[\model{\sigma}]}$ is related to the syntactic type
$A[\sigma]$. We first establish preservation of the relation by substitution for
variables:
\begin{alignat*}{5}
    % []V~
  & []{\sim} && :
  (\wf{\sigma} : \Gamma \vdash \sigma \Rightarrow \Delta) \ra
  (\wf\sigma \sim \model{\sigma}) \ra
  (\wf{x} : \Delta \vdash x \invar A) \ra
  (\wf{x} \sim \model{x}) \ra
  \\ & && \qquad
  % \\
  % & && \qquad
   \wf{[]}\wf{x}\wf{\sigma} \sim \model{x}\model{[\model{\sigma}]}
\end{alignat*}
Then we show it for terms and types  by mutual induction
under the common hypotheses
  $(\wf{\sigma} : \Gamma \vdash \sigma \Rightarrow \Delta)$,
  $(\wf\sigma \sim \model{\sigma})$,
  $(\wf{\Gamma} : \Gamma \vdash )$,
  $(\wf{\Gamma} \sim \model{\Gamma})$,
  % \\
  % &&&\qquad
    $(\wf{\Delta} : \Delta \vdash )$,
    and
  $(\wf{\Delta} \sim \model{\Delta})$:
\begin{alignat*}{5}
     & []{\sim} && :
    (\wf{A} : \Delta \vdash A) \ra
  (\wf{A} \sim \model{A}) \ra
  % \\
  % & && \qquad
   \wf{[]}\wf{\Gamma}\wf{A}\wf{\sigma} \sim \model{A}\model{[\model{\sigma}]}
   \\
     & []{\sim} && :
    (\wf{t} : \Delta \vdash t \in A ) \ra
  (\wf{t} \sim \model{t}) \ra
  % \\
  % & && \qquad
   \wf{[]}\wf{\Gamma}\wf{t}\wf{\sigma} \sim \model{t}\model{[\model{\sigma}]}
  \end{alignat*}
  Eventually, we show under the same hypotheses the following statement
  \begin{alignat*}{5}
     & {\circ}{\sim} && :
    (\wf{E} : E \vdash ) \ra
  (\wf{E} \sim \model{E}) \ra
  % \\
  % &&&  \qquad
    (\wf{\delta} : \Delta \vdash \delta \Rightarrow E) \ra
  (\wf{\delta} \sim \model{\delta}) \ra
  \\
  & && \qquad
   \wf{{\circ}}\wf{\Gamma}\wf{\delta}\wf{\sigma} \sim \model{\delta}\model{\circ}\model{\sigma}
  \end{alignat*}
  and the fact that identity preserves the relation:
  \begin{alignat*}{5}
     & {\id}{\sim} && :
    (\wf{\Gamma} : \Gamma \vdash ) \ra
  (\wf{\Gamma} \sim \model{\Gamma}) \ra
   \wf{{\id}}\wf{\Gamma} \sim {\id}_{\model{\Gamma}}
  \end{alignat*}
% $\model{t}\model\oldapp\model{u}$, but it has type
% $\model{B}\model{[0 := \model{u}]}$
% instead of type $\model{T}$. Fortunately, we know by hypothesis that $\model{T}$
% relates to $T=B[0:=u]$ so, by uniqueness of the related semantic counterpart,
% we can deduce that $\model{T}=\m$
% Thus, we need to show that $\model{T}=\model{B}\model{[0 := \model{u}]}$ if we
% know that this last type is related to $B[0 := u]$.


\subsection{The Recursor}
For the recursor, we build a morphism from the syntactic model to the semantic
one. The image of a syntactic context is a unique semantic context which is
related to it, and similarly for types and terms.
% We construct it as the semantic
% Induction on the typing judgments shows that any QIIT morphism from the
% syntactic model $S$  to a semantic model $M$ sends well-typed syntax on a related
% semantic counter-part.
Thus, as a first step, we use induction on well-formedness judgments to construct
semantic counterparts:
  \begin{alignat*}{5}
     & \Sigma\Con{\sim} && :
    (\wf{\Gamma} : \Gamma \vdash ) \ra
    \sum_{\model{\Gamma}} \wf{\Gamma} \sim \model{\Gamma}
    \\
     & \Sigma\Ty{\sim} && :
    (\wf{\Gamma} : \Gamma \vdash ) \ra
    (\wf{\Gamma}\sim \model\Gamma) \ra
    (\wf{A} : \Gamma \vdash A ) \ra
    ({\model{A}:\model{\Ty}\model\Gamma})\times ( \wf{A} \sim \model{A})
    \\
     & \Sigma\Tm{\sim} && :
    (\wf{\Gamma} : \Gamma \vdash ) \ra
    (\wf{\Gamma}\sim \model\Gamma) \ra
    (\wf{A} : \Gamma \vdash A ) \ra
    ( \wf{A} \sim \model{A}) \ra
    \\ & && \qquad
    (\wf{t} : \Gamma \vdash t \in A ) \ra
    ({\model{t}:\model{\Tm}\model\Gamma}\model{A})\times ( \wf{t} \sim \model{t})
    \\
     & \Sigma\Var{\sim} && :
    (\wf{\Gamma} : \Gamma \vdash ) \ra
    (\wf{\Gamma}\sim \model\Gamma) \ra
    (\wf{A} : \Gamma \vdash A ) \ra
    ( \wf{A} \sim \model{A}) \ra
    \\ & && \qquad
    (\wf{x} : \Gamma \vdash x \invar A ) \ra
    ({\model{x}:\model{\Tm}\model\Gamma}\model{A})\times ( \wf{x} \sim \model{x})
    \\
     & \Sigma\Sub{\sim} && :
    (\wf{\Gamma} : \Gamma \vdash ) \ra
    (\wf{\Gamma}\sim \model\Gamma) \ra
    (\wf{\Delta} : \Delta \vdash  ) \ra
    ( \wf{\Delta} \sim \model{\Delta}) \ra
    \\ & && \qquad
    (\wf{\sigma} : \Gamma \vdash \sigma \Rightarrow \Delta ) \ra
    ({\model{\sigma}:\model{\Sub}\model\Gamma}\model{\Delta})\times ( \wf{\sigma} \sim \model{\sigma})
  \end{alignat*}
  The right uniqueness of the relation is used in this induction. It is then
straightforward to show (without induction) that the first projection of these
constructions yield a model morphism from the syntax to the model, again using
right uniqueness.
\subsection{Uniqueness}
Our goal is to show that the syntactic model is initial. Thus, what remains is
to show that the morphism constructed in the previous section is unique. We
exploit right uniqueness of the relation: it is enough to show that any such
morphism maps a syntactic context to a related semantic context, and similarly
for types and terms.

More formally, we assume an arbitrary morphism from the
syntax to the model, inducing the following maps:
\begin{alignat*}{5}
  &
  \mor{\Con}
  && :
   (\Gamma \vdash) \ra \model\Con
   \\
  &
  \mor{\Ty}
  && :
   (\wf\Gamma:\Gamma \vdash) \ra (\Gamma\vdash A)\ra\model\Ty\,(\mor\Con\wf\Gamma)
   \\
  &
  \mor{\Tm}
  && :
  (\wf\Gamma:\Gamma \vdash) \ra (\wf{A}:\Gamma\vdash A)\ra
  (\Gamma\vdash t \in A)\ra\model\Tm\,(\mor\Con\wf\Gamma)\,
  (\mor\Ty\wf\Gamma\,\wf{A})
   \\
  &
  \mor{\Var}
  && :
  (\wf\Gamma:\Gamma \vdash) \ra (\wf{A}:\Gamma\vdash A)\ra
  (\Gamma\vdash x \invar A)\ra\model\Tm\,(\mor\Con\wf\Gamma)\,
  (\mor\Ty\wf\Gamma\,\wf{A})
   \\
  &
  \mor{\Sub}
  && :
  (\wf\Gamma:\Gamma \vdash) \ra
  (\wf\Delta:\Delta \vdash) \ra
  (\Gamma\vdash \sigma \Rightarrow \Delta)\ra\model\Sub\,(\mor\Con\wf\Gamma)\,
  (\mor\Con\wf\Delta)
\end{alignat*}
Then, we show by induction on typing judgments that
the image is related:
\begin{alignat*}{5}
  &
  {\sim}\mor{\Con}
  && :
  (\wf\Gamma : \Gamma \vdash) \ra \wf\Gamma\sim \mor\Con\,\wf\Gamma
  \\
  &
  {\sim}\mor{\Ty}
  && :
  (\wf\Gamma : \Gamma \vdash) \ra
  (\wf{A} : \Gamma \vdash A) \ra
  \wf\Gamma\sim \mor\Ty\,\wf\Gamma\,\wf{A}
  \\
  &
  {\sim}\mor{\Tm}
  && :
  (\wf\Gamma : \Gamma \vdash) \ra
  (\wf{A} : \Gamma \vdash A) \ra
  (\wf{t} : \Gamma \vdash t \in A) \ra
  \wf\Gamma\sim \mor\Tm\,\wf\Gamma\,\wf{A}\,\wf{t}
  \\
  &
  {\sim}\mor{\Var}
  && :
  (\wf\Gamma : \Gamma \vdash) \ra
  (\wf{A} : \Gamma \vdash A) \ra
  (\wf{x} : \Gamma \vdash x \invar A) \ra
  \wf\Gamma\sim \mor\Var\,\wf\Gamma\,\wf{A}\,\wf{x}
  \\
  &
  {\sim}\mor{\Sub}
  && :
  (\wf\Gamma : \Gamma \vdash) \ra
  (\wf{\Delta} : \Delta \vdash) \ra
  (\wf{\sigma} : \Gamma \vdash \sigma \Rightarrow \Delta) \ra
  \wf\Gamma\sim \mor\Sub\,\wf\Gamma\,\wf{\Delta}\,\wf{\sigma}
\end{alignat*}
This justifies the uniqueness of the morphism, by right uniqueness of
$\blank\sim\blank$.


% \begin{description}
%   \item[untyped syntax and well typed judgments as an algebra]
%   \begin{enumerate}
%   \item define untyped syntax as an inductive datatype
%   \item define operations on the syntax, such as substitution, by recursion
%   \item define well-typed judgments as an inductive datatype indexed over the untyped syntax
%   \item show the dependant pair of untyped syntax with well-typed judgments
%     define an algebra
%   \end{enumerate}
%   \item[specification of the initial morphism as a functional relation]
%   \begin{enumerate}
%   \item given an algebra, define the functional relation enjoyed by the recursor
%     from the syntax to the algebra by recursion over the well-typed judgment
%   \item show right-uniqueness of the relation
%   \item show left-totality of the relation
%   \end{enumerate}
%   \item[existence and uniqueness of the morphism from the syntax to a model]
%     \begin{enumerate}
%   \item show uniqueness of such a morphism
%   \item extract an algebra morphism from the relation
%     \end{enumerate}
% \end{description}
