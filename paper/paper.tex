
\documentclass[a4paper,UKenglish,cleveref, autoref]{lipics-v2019}
%This is a template for producing LIPIcs articles.
%See lipics-manual.pdf for further information.
%for A4 paper format use option "a4paper", for US-letter use option "letterpaper"
%for british hyphenation rules use option "UKenglish", for american hyphenation rules use option "USenglish"
%for section-numbered lemmas etc., use "numberwithinsect"
%for enabling cleveref support, use "cleveref"
%for enabling cleveref support, use "autoref"
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{hyperref}
\usepackage{todonotes}
\presetkeys{todonotes}{inline}{}

%\graphicspath{{./graphics/}}%helpful if your graphic files are in another directory

\bibliographystyle{plainurl}% the mandatory bibstyle

\title{For finitary induction-Induction, Induction is Enough} %TODO Please add

%% \titlerunning{For Induction-Induction, Induction is Enough}%optional, please use if title is longer than one line

\author{Ambrus Kaposi}{E{\"o}tv{\"o}s Lor{\'a}nd University, Budapest, Hungary}{akaposi@inf.elte.hu}{https://orcid.org/0000-0001-9897-8936}{this author was supported by Thematic Excellence Programme, Industry and Digitization Subprogramme (NRDI Office, 2019) and by the European Union, co-financed by the European Social Fund (EFOP-3.6.2-16-2017-00013, Thematic Fundamental Research Collaborations Grounding Innovation in Informatics and Infocommunication).}%TODO mandatory, please use full name; only 1 author per \author macro; first two parameters are mandatory, other parameters can be empty. Please provide at least the name of the affiliation and the country. The full address is optional
\author{Andr{\'a}s Kov{\'a}cs}{E{\"o}tv{\"o}s Lor{\'a}nd University, Budapest, Hungary}{kovacsandras@inf.elte.hu}{https://orcid.org/0000-0002-6375-9781}{this author was supported by the European Union, co-financed by the European Social Fund (EFOP-3.6.3-VEKOP-16-2017-00002).}
\author{Ambroise Lafont}{IMT Atlantique, Inria, LS2N CNRS, Nantes, France}{ambroise.lafont@inria.fr}{https://orcid.org/0000-0002-9299-641X}{}

\authorrunning{A. Kaposi, A. Kov{\'a}cs and A. Lafont}%TODO mandatory. First: Use abbreviated first/middle names. Second (only in severe cases): Use first author plus 'et al.'

\Copyright{A. Kaposi, A. Kov{\'a}cs and A. Lafont}%TODO mandatory, please use full first names. LIPIcs license is "CC-BY";  http://creativecommons.org/licenses/by/3.0/

\ccsdesc[500]{Theory of computation~Logic~Type theory}%TODO mandatory: Please choose ACM 2012 classifications from https://dl.acm.org/ccs/ccs_flat.cfm

\keywords{type theory, inductive types, inductive-inductive types}%TODO mandatory; please add comma-separated list of keywords

\category{}%optional, e.g. invited paper

\relatedversion{}%optional, e.g. full version hosted on arXiv, HAL, or other respository/website
%\relatedversion{A full version of the paper is available at \url{...}.}

\supplement{}%optional, e.g. related research data, source code, ... hosted on a repository like zenodo, figshare, GitHub, ...

%\funding{(Optional) general funding statement \dots}%optional, to capture a funding statement, which applies to all authors. Please enter author specific funding statements as fifth argument of the \author macro.

\acknowledgements{The authors would like to thank Thorsten Altenkirch, Simon Boulier, Fredrik Nordvall-Forsberg and Jakob von Raumer for discussions on the topics of this paper.}%optional

%\nolinenumbers %uncomment to disable line numbering

%\hideLIPIcs  %uncomment to remove references to LIPIcs series (logo, DOI, ...), e.g. when preparing a pre-final version to be uploaded to arXiv or another public repository

%Editor-only macros:: begin (do not touch as author)%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\EventEditors{John Q. Open and Joan R. Access}
\EventNoEds{2}
\EventLongTitle{42nd Conference on Very Important Topics (CVIT 2016)}
\EventShortTitle{CVIT 2016}
\EventAcronym{CVIT}
\EventYear{2016}
\EventDate{December 24--27, 2016}
\EventLocation{Little Whinging, United Kingdom}
\EventLogo{}
\SeriesVolume{42}
\ArticleNo{23}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\input{abbrevs.tex}

\allowdisplaybreaks

\begin{document}
\maketitle

\begin{abstract}
  Inductive-inductive types (IITs) are a generalisation of inductive types in
  type theory. They allow the mutual definition of types with multiple sorts
  where later sorts can be indexed by previous ones. An example is the James
  Chapman-style syntax of type theory with conversion relations for each sort
  where e.g.\ the sort of types is indexed by contexts. It follows from previous
  work by T. Altenkirch, A. Kaposi, and A. Kov{\'a}cs, that all finitary IITs can be constructed from a quotient
  inductive-inductive type (QIIT), namely the theory of IIT signatures. This is
  a small domain-specific type theory where a context is a signature for an
  IIT. In this paper we construct the theory of IIT signatures using only inductive types,
  thereby showing a reduction of all finitary IITs to inductive types.  We rely
  on function extensionality and uniqueness of identity proofs. We formalised
  the construction of the theory of IIT signatures in Agda.
\end{abstract}

\section{Introduction}
\label{sec:intro}

Many mutual inductive types can be reduced to indexed inductive types, where the
index disambiguates different sorts. An example is the mutual inductive datatype
with two sorts
$\mathsf{isEven}$ and $\mathsf{isOdd}$, defined by the following
constructors.
\begin{alignat*}{5}
  & \mathsf{isEven} && : \N\ra\Set \\
  & \mathsf{isOdd} && : \N\ra \Set \\
  & \mathsf{zeroEven} && : \mathsf{isEven}\,\mathsf{zero} \\
  & \mathsf{sucEven} && : (n:\N)\ra\mathsf{isOdd}\,n\ra\mathsf{isEven}\,(n+1) \\
  & \mathsf{sucOdd} && : (n:\N)\ra\mathsf{isEven}\,n\ra\mathsf{isOdd}\,(n+1)
\end{alignat*}
These can be reduced to the following single inductive family.
\begin{alignat*}{5}
  & \mathsf{isEven?} && : \mathsf{Bool}\ra\N\ra\Set \\
  & \mathsf{zeroEven} && : \mathsf{isEven?}\,\mathsf{true}\,\mathsf{zero} \\
  & \mathsf{sucEven} && : (n:\N)\ra\mathsf{isEven?}\,\mathsf{false}\,n\ra\mathsf{isEven?}\,\mathsf{true}\,(n+1) \\
  & \mathsf{sucOdd} && : (n:\N)\ra\mathsf{isEven?}\,\mathsf{true}\,n\ra\mathsf{isEven?}\,\mathsf{false}\,(n+1)
\end{alignat*}

Inductive-inductive types (IITs \cite{forsberg-phd}) allow the mutual
definition of a type and a family of types over the first one. IITs
were originally introduced to represent the well-typed syntax of type
theory itself, and the main example is still the Chapman-style
\cite{chapman09eatitself} syntax for a type theory. A minimal use case
is the IIT of contexts and types given by the following constructors.
\begin{alignat*}{5}
  & \Con && : \Set \\
  & \Ty && : \Con\ra\Set \\
  & \mathsf{empty} && : \Con \\
  & \mathsf{ext} && : (\Gamma:\Con)\ra\Ty\,\Gamma\ra\Con \\
  & \mathsf{U} && : (\Gamma:\Con)\ra\Ty\,\Gamma \\
  & \mathsf{El} && : (\Gamma:\Con)\ra\Ty\,(\mathsf{ext}\,\Gamma\,(\mathsf{U}\,\Gamma))
%  & \mathsf{Pi} && : (\Gamma:\Con)(A:\Ty\,\Gamma)\ra\Ty\,(\mathsf{ext}\,\Gamma\,A)\ra\,\Ty\,\Gamma
\end{alignat*}
This type has two sorts, $\Con$ and $\Ty$. The $\mathsf{ext}$ constructor of
$\Con$ refers to $\Ty$ and the $\Ty$-constructor $\mathsf{U}$ refers to $\Con$,
hence the two sorts have to be defined simultaneously. Moreover, $\Ty$ is
indexed over $\Con$. This precludes a reduction analogous to the reduction of
$\mathsf{isEven}$--$\mathsf{isOdd}$, as we would get a type indexed over
itself. Another unique feature of IITs (which also shows up in higher inductive
types \cite{HoTTbook}) is that later constructors can refer to previous
constructors: in our case, $\mathsf{El}$ mentions
$\mathsf{ext}$.
% \[
%   \mathsf{Con?} : (b:\mathsf{Bool})\ra\mathsf{if}\,b\,\mathsf{then}\,\Set\,\mathsf{else}\,(\mathsf{Con?}\,\mathsf{false}\ra\Set),
% \]

The elimination principle for the above IIT has two motives and one method
for each constructor. It is an example of a \emph{recursive-recursive}
function (following the nomenclature of \cite{forsberg-phd}) which
means that there are two mutually defined functions, where the type of
the second function depends on the first function. The proof assistant
Agda \cite{norell07thesis} allows the definition of such functions
(even from non-IITs) and it is also currently the only proof assistant
supporting IITs\footnote{An experimental version of Coq with IITs is also
  available on github.}.

We now state  
the elimination principle for $\Con$--$\Ty$.
We implicitly universally quantify over the variables $\Gamma$ of type $\Con$
and $A$ of type $\Ty$ when required (later in the development, we may similarly omit universal quantification).
Given the following components,
\begin{alignat*}{5}
  & \Con^D && : \Con\ra\Set \\
  & \Ty^D && : \Con^D\,\Gamma\ra\Ty\,\Gamma\ra\Set \\
  & \mathsf{empty}^D && : \Con^D\,\mathsf{empty} \\
  & \mathsf{ext}^D && : (\Gamma^D:\Con^D\,\Gamma)\ra \Ty^D\,\Gamma^D\,A\ra \Con^D\,(\mathsf{ext}\,\Gamma\,A) \\
  & \U^D && : (\Gamma^D:\Con^D\,\Gamma)\ra \Ty^D\,\Gamma^D\,(\mathsf{U}\,\Gamma) \\
  & \El^D && : (\Gamma^D:\Con^D\,\Gamma)\ra\,\Ty^D\,(\mathsf{ext}^D\,\Gamma^D\,(\U^D\,\Gamma^D))\,(\mathsf{El}\,\Gamma)
%  & Pi^D && : (\Gamma^D:\Con^D\,\Gamma)(A^D:\Ty^D\,\Gamma^D\,A)\ra \Ty^D\,(\mathsf{ext}^D\,\Gamma^D\,A^D)\ra\,\Ty^D\,\Gamma^D\,(\mathsf{Pi}\,\Gamma\,A\,B)
\end{alignat*}
we obtain two functions
\begin{alignat*}{5}
  & \mathsf{elimCon} && : (\Gamma:\Con)\ra \Con^D\,\Gamma \\
  & \mathsf{elimTy} && : (A:\Ty\,\Gamma)\ra \Ty^D\,(\mathsf{elimCon}\,\Gamma)
\end{alignat*}
with the following computation rules.
\begin{alignat*}{5}
  & \mathsf{elimCon}\,\mathsf{empty} && = \mathsf{empty}^D \\
  & \mathsf{elimCon}\,(\mathsf{ext}\,\Gamma\,A) && = \mathsf{ext}^D\,(\mathsf{elimCon}\,\Gamma)\,(\mathsf{elimTy}\,A) \\
  & \mathsf{elimTy}\,(\mathsf{U}\,\Gamma) && = \U^D\,(\mathsf{elimCon}\,\Gamma) \\
  & \mathsf{elimTy}\,(\mathsf{El}\,\Gamma) && = \El^D\,(\mathsf{elimCon}\,\Gamma)
\end{alignat*}

Reducing IITs to inductive types is an open problem. Forsberg
\cite{forsberg-phd} showed a reduction which only supports a simpler,
non-recursive-recursive elimination principle. Hugunin \cite{jasper} reduced
several IITs to inductive types, working inside a cubical type theory, but he
also only constructed a weaker eliminator.

The theory of signatures in \cite{Kaposi:2019:CQI:3302515.3290315} is a small
type theory in which every context encodes a valid quotient inductive-inductive
type (QIIT) signature. For example, the signature for natural numbers is simply
the context $(Nat:\U,zero:Nat,suc:Nat\ra Nat)$ of length three ($Nat$, $zero$
and $suc$ are variable names). \cite{Kaposi:2019:CQI:3302515.3290315} showed
that if this theory of signatures exists, then any finitary QIIT can be derived
from it via a term model construction.
Here, by finitary QIIT, we mean that infinitary constructors, such as the following
one, are not allowed:
\[ TODO \]
If we omit the type former for equality
constructors from the theory of signatures, we get a theory of finitary IIT
signatures, and the construction of \cite{Kaposi:2019:CQI:3302515.3290315} still
works: constructing an arbitrary IIT from the theory of IIT signatures does not
need the $\mathsf{Id}$ type former to be present.

However, the QIIT term model construction assumes that we already have the
syntax of QIIT signatures, and we can do induction over it. Hence, it only shows
that all finitary QIITs are derivable from a particular fairly complicated QIIT.
Likewise, restricted to finitary IITs, we only know that they are constructible
from a particular QIIT.

In this paper, we construct the theory of IIT signatures, which is a large
infinitary QIIT, using only indexed inductive types, uniqueness of identity
types (UIP) and function extensionality. Thus, we show that all finitary IITs are
reducible to the same feature set.

The contents of this paper were presented at the TYPES 2019 conference
in Oslo \cite{types}.

\subsection{Structure of the Paper}

We first define a theory of IIT signatures in which every context is a signature
(Section \ref{sec:theory_of_signatures}). We present this as an algebraic
\cite{ttintt} theory, specifically as a quotient inductive-inductive type
(QIIT). In Section \ref{sec:ambroise} we show that this QIIT can be constructed
using inductive types, UIP and function extensionality. In Section
\ref{sec:constructingiits} we describe the construction of IITs from the syntax
of IIT signatures.


%% To derive the existence of all IITs from the theory of IIT signatures
%% we use a variant of the CwF model
%% \cite{Kaposi:2019:CQI:3302515.3290315} where types are modelled not by
%% displayed CwFs but by CwF isofibrations. We need this extension to
%% support infinitary constructors. Furthermore, using the method
%% introduced by Streicher \cite{streichersemantics} we show the
%% existence of the theory of IIT signatures. As opposed to Streicher, we
%% don't use quotients in this construction as the theory of IIT
%% signatures can be given only using neutral terms.

%% Our metatheory is ETT. Using Hofmann \cite{}, Theo \cite{} translation
%% we can translate our arguments to ITT+UIP+funext. Section
%% \ref{sec:ambroise} was formalised in Agda using UIP, rewrite rules and
%% funext.

%% This is the paper version of our TYPES 2019 talk.

\subsection{Related Work}

The current work builds heavily on the work of Kaposi et al.\ on quotient
inductive-inductive types \cite{Kaposi:2019:CQI:3302515.3290315}; we reuse both
QIIT syntax and semantics by restricting to IITs, and we reuse the term model
construction of QIITs as well.

Forsberg \cite{forsberg-phd} specifies inductive-inductive types and develops a
semantics based on dialgebras. He also provides a reduction of IITs to indexed
inductive types, but only constructs a weak version of the eliminator.

Hugunin \cite{jasper} constructs several IITs in cubical Agda from inductive
types. In this setting, the lack of UIP makes constructions significantly more
involved, and essentially involves coinductive-coinductive well-formedness
predicates defined as homotopy limits. Hugunin does not consider a generic
syntax of IITs and only works on specific examples (although the examples vary
greatly). He also does not construct full recursive-recursive eliminators.

Streicher \cite{streichersemantics} presents an interpretation of the well-formed
presyntax of a type theory into a categorical model, which is an important
ingredient in constructing an initial model, although he does not present
details on the construction of the term model or its initiality proof. Our initiality proof can be seen as an indexed variant of his construction (see Subsection \ref{sec:streicher} for a comparison).

Voevodsky was interested in constructing initial models of type
theories from presyntaxes. Inspired by this, Brunerie et al.\ \cite{brunerie}
formalised Streicher's proof in Agda for a type theory with $\Pi$,
$\Sigma$, $\mathbb{N}$, identity types and an infinite hierarchy of
universes. He used UIP, function extensionality and quotient types in
his formalisation. In this paper we construct a type theory without
computation rules, hence we avoid using quotients.

Intrinsic (well-typed) syntax for type theories were constructed using
IITs \cite{chapman09eatitself}, inductive-recursive types
\cite{nisse,Altenkirch:2014:CO:2631172.2631176} and QIITs
\cite{ttintt}. In this paper we avoid using such general classes of
inductive types as our goal is to reduce IITs to indexed inductive
types.

Reducing general classes of inductive types to simpler classes has a
long tradition in type theory. Indexed W-types were reduced to W-types
\cite{indexedcont} (using the essentially Streicher's idea of preterms
and a typing predicate), small inductive-recursive types to indexed
W-types \cite{malatasta13smallir}, mutual inductive types to indexed
W-types \cite{mutual}, W-types to natural numbers and quotients
\cite{Ahrens2019}. Quotient inductive-inductive types (and
inductive-inductive types) can be reduced to quotient inductive types
using the reduction of generalised algebraic theories to essentially
algebraic theories \cite{gat}.

Our reduction of IITs to indexed inductive types goes through two
steps: first we construct a concrete QIIT using inductive types, then
we construct all IITs from this particular QIIT. A more direct
approach is proposed by \cite{erasure}: here the initial algebra would
be constructed directly for any IIT signature without going through an
intermediate step.

\subsection{Metatheory and Notation}

We work in intensional Martin-Löf type theory, equipped with the following features:
\begin{itemize}
  \item Predicative universes $\Set_i$. We usually omit level indices in this paper.
  \item Dependent functions, notated as $(x : A)\ra B$, or as $A \ra B$ when
    non-dependent. We sometimes omit function arguments, by implicitly
    generalising over variables.
  \item $\Sigma$-types, notated either as $(x : A)\times B$, or as $\sum\limits_{x} B$
        when we want to leave the type of the first projection implicit. We use $A
        \times B$ for non-dependent pairs.
  \item Intensional propositional equality as $t = u$, with $\refl : t = t$. In
    this paper, we informally use extensional notation, and do not write
    explicit transports over equalities. However, we occasionally indicate by
    $e_1,\dots,e_n \#t$ that $t$ is well-typed thanks to the equalities
    $e_1$,\dots,$e_n$.
  \item Uniqueness of identity proofs (UIP), expressing $(e : t = t)\ra e = \refl$.
  \item Function extensionality, expressing $((x : A) \ra f\,x = g\,x) \ra f = g$.
  \item Natural numbers $\mathbb{N}$ with constructors $\mathsf{0}:\mathbb{N}$ and $\mathsf{S}:\mathbb{N}\ra\mathbb{N}$.

\end{itemize}

\subsection{Formalisation}

Agda formalisation of Sections \ref{sec:theory_of_signatures} and
\ref{sec:ambroise} can be found at
\url{https://github.com/amblafont/UniversalII}. In addition to the features in
the previous section, this formalisation also uses equality reflection for some
equalities, through rewriting pragmas \cite{cockxsprinkles}. This is purely for
convenience, and in principle we could eliminate the instances of equality
reflection via UIP and function extensionality.

\section{The Theory of IIT Signatures}
\label{sec:theory_of_signatures}

The theory of IIT signatures is given as a category with families
(CwF) \cite{Dybjer96internaltype} with certain additional type formers. The CwF
part constitutes the substitution calculus, while the type formers allow
declaring new sorts and operators in a signature. Below, we list all components
for the theory of signatures; this can be viewed as a notion of model for the
theory, which is an iterated $\Sigma$ type. In this paper, we construct the
\emph{initial} such model, i.e.\ a model equipped with a unique recursion principle.

Here, initiality refers to the notion of homomorphism between models deduced
from the general theory of large infinitary QIITs developed in \cite{large_inf_qiit}.
Roughly, a homomorphism is a functor between underlying
categories which strictly preserves all additional family structure and type
formers.

\begin{alignat*}{5}
  & \rlap{(1) Substitution calculus} \\[0.5em]
  & \Con && : \Set \\
  & \Ty  && : \Con\ra\Set \\
  & \Sub  && : \Con\ra\Con\ra\Set \\
  & \Tm  && : (\Gamma:\Con)\ra\Ty\,\Gamma\ra\Set \\
  & \id && : \Sub\,\Gamma\,\Gamma \\
  & \blank\circ\blank && : \Sub\,\Theta\,\Delta\ra\Sub\,\Gamma\,\Theta\ra\Sub\,\Gamma\,\Delta \\
  & \ass && : (\sigma \circ \delta) \circ \nu = \sigma \circ (\delta \circ \nu) \\
  & \idl && : \id\circ\sigma = \sigma \\
  & \idr && : \sigma\circ\id = \sigma \\
  & \blank[\blank] && : \Ty\,\Delta\ra\Sub\,\Gamma\,\Delta\ra\Ty\,\Gamma \\
  & \blank[\blank] && : \Tm\,\Delta\,A\ra(\sigma:\Sub\,\Gamma\,\Delta)\ra\Tm\,\Gamma\,(A[\sigma]) \\
  & [\id] && : A[\id] = A \\
  & [\circ] && : A[\sigma \circ \delta] = A[\sigma][\delta] \\
  & [\id] && : t[\id] = t \\
  & [\circ] && : t[\sigma \circ \delta] = t[\sigma][\delta] \\
  & \boldsymbol{\cdot} && : \Con \\
  & \epsilon && : \Sub\,\Gamma\,\boldsymbol{\cdot} \\
  & {\boldsymbol{\cdot}\eta} && : \{\sigma : \Sub\,\Gamma\,\boldsymbol{\cdot}\} \ra \sigma = \epsilon \\
  & \blank\ext\blank && : (\Gamma:\Con)\ra\Ty\,\Gamma\ra\Con \\
  & \blank,\blank && : (\sigma:\Sub\,\Gamma\,\Delta)\ra\Tm\,\Gamma\,(A[\sigma])\ra\Sub\,\Gamma\,(\Delta\ext A) \\
  & \pi_1 && : \Sub\,\Gamma\,(\Delta\ext A)\ra \Sub\,\Gamma\,\Delta \\
  & \pi_2 && : (\sigma : \Sub\,\Gamma\,(\Delta\ext A))\ra \Tm\,\Gamma\,(A[\pi_1 \sigma]) \\
  & {\pi_1\beta} && : \pi_1(\sigma, t) = \sigma \\
  & {\pi_2\beta} && : \pi_2(\sigma, t) = t \\
  & {\pi\eta} && : (\pi_1\,\sigma, \pi_2\,\sigma) = \sigma \\
  & {,\circ} && : (\sigma, t)\circ\delta = (\sigma\circ\delta, t[\delta]) \\[0.5em]
  & \rlap{(2) Universe} \\[0.5em]
  & \U && : \Ty\,\Gamma \\
  & \El && : \Tm\,\Gamma\,\U\ra\Ty\,\Gamma \\
  & {\U[]} && : \U[\sigma] = \U \\
  & {\El[]} && : (\El\,a)[\sigma] = \El\,(a[\sigma]) \\[0.5em]
  & \rlap{(3) Inductive parameters} \\[0.5em]
  & \Pi && : (a:\Tm\,\Gamma\,\U)\ra\Ty\,(\Gamma\ext\El\,a)\ra\Ty\,\Gamma \\
  & \blank\oldapp\blank && : \Tm\,\Gamma\,(\Pi\,a\,B)\ra (u : \Tm\,\Gamma\,(\El\,a))
  \ra \Tm\,\Gamma\,(\El\,(B[\id,\,u])) \\
  & {\Pi[]} && : (\Pi\,a\,B)[\sigma] = \Pi\,(a[\sigma])\,(B[\sigma^\uparrow]) \\
  & {\oldapp[]} && : (t\oldapp\alpha)[\sigma] = (t[\sigma])\mathop{\oldapp}(\alpha[\sigma]) \\[0.5em]
  & \rlap{(4) Metatheoretic parameters} \\[0.5em]
  & \Pim && : (T:\Set)\ra(T\ra\Ty\,\Gamma)\ra\Ty\,\Gamma \\
  & \blank\appm \blank && : \Tm\,\Gamma\,(\Pim\,T\,B)\ra(\alpha:T) \ra\Tm\,\Gamma\,(B\,\alpha) \\
  & {\Pim[]} && : (\Pim\,T\,B)[\sigma] = \Pim\,T\,(\lambda \alpha.(B\,\alpha)[\sigma]) \\
  & {\appm[]} && : (t\appm\alpha)[\sigma] = (t[\sigma])\mathop{\appm}\alpha \\[0.5em]
\end{alignat*}
\subsection{Notation and abbreviations}

We define $\wk : \Sub\,(\Gamma\ext A)\ra \Gamma$ as $\pi_1\,\id$.
We can recover de Bruijn indices by having $0= \pi_2 \,\id$ and $n+1 = n[\wk]$.
However, for informal examples we instead
use a nameful notation, where we introduce names in context extension and in the
$\Pi$ function domain, for example as $\boldsymbol{\cdot}\,\ext\,A : \U\,\ext\,a :
\El\,A$ in a signature for pointed sets.

We define $\sigma^\uparrow$ as $(\sigma\circ\wk,0)$.
We also abbreviate non-dependent $\Pi$ functions by writing $\Pi\,a\,(B[\wk])$ as $a\Ra B$.


\subsection{Example signatures}

Natural numbers:
\[
\boldsymbol{\cdot}\,\ext\,N:\U\,\ext\,z : \El\,N\,\ext\,s : N \Ra \El\,N
\]
Lists with elements of a given $A : \Set$ type. Here we use the $\Pim$ function
to include an external type into the signature.
\[
\boldsymbol{\cdot}\,\ext\,L:\U\,\ext\,nil : \El\,L\,\ext\,
      cons : \Pim\,A\,(\lambda \_.\, L\Ra \El\,L)
\]
The inductive-inductive example from Section \ref{sec:intro}:
\begin{alignat*}{3}
  & \boldsymbol{\cdot} \,\ext\,Con : \U\,\ext\,Ty : Con\Ra\U\,\ext\,empty : \El\,Con\,\ext\,ext : \Pi\,(\Gamma : Con)\,(Ty\oldapp\Gamma \Ra Con) \\
  & \hspace{0.5em}\,\ext\, U : \Pi\,(\Gamma:Con)\,(\El\,(Ty\oldapp\Gamma))
    \,\ext\,El : \Pi\,(\Gamma : Con)(\El\,(Ty\oldapp(ext\oldapp\Gamma\oldapp (U\oldapp\Gamma))))
\end{alignat*}

\section{Constructing the Theory of IIT Signatures}
\label{sec:ambroise}

%% \todo{Write this section}

%% Show that the theory of IIT signatures as described in Section
%% \ref{sec:theory_of_signatures} exists, that is, it can be defined only
%% using indexed inductive types and a $\Prop$ sort.

%% Ambroise has done this in Agda with funext and UIP using an
%% extrinsic--intrinsic translation.

%% Ambroise formalisation: \url{https://github.com/amblafont/UniversalII/tree/cwf-syntax/Cwf}.

%% In this formalization, there is a discrepancy for the typing rule of application
%% compared to the one of Section~\ref{sec:theory_of_signatures}: it is not
%% \[
%%    \app  : \Tm\,\Gamma\,(\Pi\,a\,B)\ra\Tm\,(\Gamma\ext \El\,a)\,B
%% \]
%% but
%% \[
%%    \app  : \Tm\,\Gamma\,(\Pi\,a\,B)\ra(u : \Tm\,\Gamma\,(\El\,a))\ra\,\Tm\,\Gamma\,B[<u>].
%% \]
%% Actually, I started with the first version, but at some point I
%% changed for the second one because it made some stuff easier (although
%% I don't remember exactly what it was).

%% I think this should be doable with only UIP (or a $\Prop$-valued
%% equality type?) and not funext. This would be important for a
%% computational justification of IITs.

%% Unfortunately, it seems that funext is needed (see the use of funext in
%% Syntax.agda) for the metatheoretic/infinitary
%% parameters part (4-5), for example in the case of the metatheoretic
%% $ \Pim  : (T:\Set)\ra(T\ra\Ty\,\Gamma)\ra\Ty\,\Gamma $. This needs to be
%% investigated more carefully.

\input{universaliit}

\section{Constructing IITs from the Theory of IIT Signatures}
\label{sec:constructingiits}

We construct all IITs describable by the theory of IIT signatures through the
term model construction of \cite{Kaposi:2019:CQI:3302515.3290315}. There, it is
shown that from the syntax of the theory of signatures for finitary QIITs, one
can construct any particular finitary QIIT. The idea is that for a signature
$\Gamma$, the initial algebra can be built from sets of terms of the form
$\Tm\,\Gamma\,(\El\,a)$. For example, considering the signature for natural
numbers
\[
  \Gamma := \big(\boldsymbol{\cdot}\,\ext\,N:\U\,\ext\,z : \El\,N\,\ext\,s : N \Ra \El\,N\big),
\]
we have that $\Tm\,\Gamma\,(\El\,N)$ is the set of natural numbers up to isomorphism,
since the only way to construct these terms is by using $s$ and $z$ from $\Gamma$.

In this section, we only need to check that the signatures and term model
construction in \cite{Kaposi:2019:CQI:3302515.3290315} restrict to IITs,
i.e.\ that from a syntax for the theory of IIT signatures all finitary IITs are
constructible.

\begin{enumerate}
\item
  Finitary IIT signatures are obtained exactly by dropping equality constructors from
  finitary QIIT signatures. It follows that any model for the theory of QIIT signatures
  restricts to IITs, hence we inherit the categorical semantics of QIITs.
\item
  The term model construction also restricts in a straightforward way. For QIITs,
  term algebras are constructed by induction on the syntax of signatures, and
  then another induction constructs the eliminator (i.e.\ dependent induction
  principle). In both cases, simply dropping equality constructors from the
  induction yields restriction to IITs.
\end{enumerate}

However, we shall mention that the Agda formalisation for the current paper
cannot be directly plugged into the Agda code for
\cite{Kaposi:2019:CQI:3302515.3290315} (which includes most of the term model
construction). One reason is that the QIIT formalisation uses strict computation
rules (given by Agda rewrite rules) for induction over signatures, while here we show propositional
computation. This mismatch can be in principle remedied by noting that both
formalisations use UIP and function extensionality, hence we can switch between
strict and propositional equalities, via the known translations between
extensional and intensional type
theories \cite{hofmann95extensional,winterhalter2019eliminating}.

Also, the current paper proves initiality, i.e.\ unique recursion for
signatures, while \cite{Kaposi:2019:CQI:3302515.3290315} uses dependent
elimination. We expect that the two notions are equivalent. An extension of
\cite{Kaposi:2019:CQI:3302515.3290315} to large infinitary QIITs would entail
this equivalence, since that would cover the (large, infinitary) theory of IIT
signatures.


\section{Further Work}

The current work only concerns finitary IITs. An extension would be to also
allow infinitely branching inductive types such as W-types. This would first
require giving semantics for infinitary IITs (to our knowledge there is no
previously published semantics that we can borrow), and also giving a term model
construction analogously to finitary QIITs. These steps seem feasible. However,
it seems to be more difficult to construct the syntax of infinitary IIT
signatures without using quotients. The reason is that such syntax would not be
strictly restricted to neutral terms: we would need $\lambda$-abstraction and
$\beta\eta$-rules for infinitary $\Pi$ types, in order to allow a term model
construction for infinitary IITs. A definition of normal preterms and typing
judgments on them may still be possible, but it appears to be much more
complicated than before (the current authors have attempted this without
conclusive success).

As mentioned in Section \ref{sec:right_uniqueness}, it also remains an open
problem whether IITs are reducible to inductive types in a UIP-free setting. To
show this, we would need to construct the syntax of signatures without UIP, and
also reproduce the semantics and term model construction for IITs without UIP.

\bibliography{b}

\end{document}
