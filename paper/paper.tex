
\documentclass[a4paper,UKenglish,cleveref, autoref]{lipics-v2019}
%This is a template for producing LIPIcs articles.
%See lipics-manual.pdf for further information.
%for A4 paper format use option "a4paper", for US-letter use option "letterpaper"
%for british hyphenation rules use option "UKenglish", for american hyphenation rules use option "USenglish"
%for section-numbered lemmas etc., use "numberwithinsect"
%for enabling cleveref support, use "cleveref"
%for enabling cleveref support, use "autoref"
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{hyperref}
\usepackage{todonotes}
\presetkeys{todonotes}{inline}{}
\usepackage{csquotes} %for \llbracket and \rrbracket
\usepackage{stmaryrd}
% \usepackage{pdflscape} % if we want \begin{landscape} ... \end{landscape}

%\graphicspath{{./graphics/}}%helpful if your graphic files are in another directory

\bibliographystyle{plainurl}% the mandatory bibstyle

\title{For Finitary Induction-Induction, \\ Induction is Enough} %TODO Please add

\titlerunning{For Finitary Induction-Induction, Induction is Enough}%optional, please use if title is longer than one line

\author{Ambrus Kaposi}{E{\"o}tv{\"o}s Lor{\'a}nd University, Budapest, Hungary}{akaposi@inf.elte.hu}{https://orcid.org/0000-0001-9897-8936}{this author was supported by the National Research,
Development and Innovation Fund of Hungary, financed under the
Thematic Excellence Programme funding scheme, Project
no.\ ED18-1-2019-0030 (Application-specific highly reliable IT
solutions), by the New National Excellence Program of the Ministry
for Innovation and Technology, Project no.\ ÃšNKP-19-4-ELTE-874, and
by the Bolyai Fellowship of the Hungarian Academy of Sciences,
Project no.\ BO/00659/19/3.}%TODO mandatory, please use full name; only 1 author per \author macro; first two parameters are mandatory, other parameters can be empty. Please provide at least the name of the affiliation and the country. The full address is optional
\author{Andr{\'a}s Kov{\'a}cs}{E{\"o}tv{\"o}s Lor{\'a}nd University, Budapest, Hungary}{kovacsandras@inf.elte.hu}{https://orcid.org/0000-0002-6375-9781}{this author was supported by the European Union, co-financed by the European Social Fund (EFOP-3.6.3-VEKOP-16-2017-00002).}
\author{Ambroise Lafont}{IMT Atlantique, Inria, LS2N CNRS, Nantes, France}{ambroise.lafont@gmail.com}{https://orcid.org/0000-0002-9299-641X}{this author was supported by the CoqHoTT ERC Grant 637339.}

\authorrunning{A. Kaposi, A. Kov{\'a}cs and A. Lafont}%TODO mandatory. First: Use abbreviated first/middle names. Second (only in severe cases): Use first author plus 'et al.'

\Copyright{A. Kaposi, A. Kov{\'a}cs and A. Lafont}%TODO mandatory, please use full first names. LIPIcs license is "CC-BY";  http://creativecommons.org/licenses/by/3.0/

\ccsdesc[500]{Theory of computation~Logic~Type theory}%TODO mandatory: Please choose ACM 2012 classifications from https://dl.acm.org/ccs/ccs_flat.cfm

\keywords{type theory, inductive types, inductive-inductive types}%TODO mandatory; please add comma-separated list of keywords

\category{}%optional, e.g. invited paper

\relatedversion{}%optional, e.g. full version hosted on arXiv, HAL, or other respository/website
%\relatedversion{A full version of the paper is available at \url{...}.}

\supplement{}%optional, e.g. related research data, source code, ... hosted on a repository like zenodo, figshare, GitHub, ...

%\funding{(Optional) general funding statement \dots}%optional, to capture a funding statement, which applies to all authors. Please enter author specific funding statements as fifth argument of the \author macro.

\acknowledgements{The authors would like to thank Thorsten Altenkirch, Rafa{\"e}l Bocquet, Simon Boulier, Fredrik Nordvall-Forsberg and Jakob von Raumer for discussions on the topics of this paper. We also thank the anonymous reviewers for their helpful comments and suggestions.}%optional

%\nolinenumbers %uncomment to disable line numbering

%\hideLIPIcs  %uncomment to remove references to LIPIcs series (logo, DOI, ...), e.g. when preparing a pre-final version to be uploaded to arXiv or another public repository

%Editor-only macros:: begin (do not touch as author)%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\EventEditors{John Q. Open and Joan R. Access}
\EventNoEds{2}
\EventLongTitle{42nd Conference on Very Important Topics (CVIT 2016)}
\EventShortTitle{CVIT 2016}
\EventAcronym{CVIT}
\EventYear{2016}
\EventDate{December 24--27, 2016}
\EventLocation{Little Whinging, United Kingdom}
\EventLogo{}
\SeriesVolume{42}
\ArticleNo{23}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\input{abbrevs.tex}

\allowdisplaybreaks

\begin{document}
\maketitle

\begin{abstract}
  Inductive-inductive types (IITs) are a generalisation of inductive
  types in type theory. They allow the mutual definition of types with
  multiple sorts where later sorts can be indexed by previous ones. An
  example is the Chapman-style syntax of type theory with conversion
  relations for each sort where e.g.\ the sort of types is indexed by
  contexts. In this paper we show that if a model of extensional type
  theory (ETT) supports indexed W-types, then it supports finitely
  branching IITs. We use a small internal type theory called the
  theory of signatures to specify signatures for IITs. We show that if
  a model of ETT supports the syntax for the theory of signatures,
  then it supports all IITs. We construct this syntax from indexed
  W-types using preterms and typing relations and prove its initiality
  following Streicher. The construction of the syntax and its
  initiality proof were formalised in Agda.
\end{abstract}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Introduction}
\label{sec:intro}

Many mutual inductive types can be reduced to indexed inductive types, where the
index disambiguates different sorts. For example, consider the mutual inductive datatype
with two sorts
$\mathsf{isEven}$ and $\mathsf{isOdd}$, defined by the following
constructors.
\begin{alignat*}{5}
  & \mathsf{isEven} && : \N\ra\Set \\
  & \mathsf{isOdd} && : \N\ra \Set \\
  & \mathsf{zeroEven} && : \mathsf{isEven}\,\mathsf{zero} \\
  & \mathsf{sucEven} && : (n:\N)\ra\mathsf{isOdd}\,n\ra\mathsf{isEven}\,(\mathsf{suc}\,n) \\
  & \mathsf{sucOdd} && : (n:\N)\ra\mathsf{isEven}\,n\ra\mathsf{isOdd}\,(\mathsf{suc}\,n)
\end{alignat*}
This can be reduced to the following single inductive family where
$\mathsf{isEven?}\,\mathsf{true}$ represents $\mathsf{isEven}$ and
$\mathsf{isEven?}\,\mathsf{false}$ represent $\mathsf{isOdd}$.
\begin{alignat*}{5}
  & \mathsf{isEven?} && : \mathsf{Bool}\ra\N\ra\Set \\
  & \mathsf{zeroEven} && : \mathsf{isEven?}\,\mathsf{true}\,\mathsf{zero} \\
  & \mathsf{sucEven} && : (n:\N)\ra\mathsf{isEven?}\,\mathsf{false}\,n\ra\mathsf{isEven?}\,\mathsf{true}\,(\mathsf{suc}\,n) \\
  & \mathsf{sucOdd} && : (n:\N)\ra\mathsf{isEven?}\,\mathsf{true}\,n\ra\mathsf{isEven?}\,\mathsf{false}\,(\mathsf{suc}\,n)
\end{alignat*}

Inductive-inductive types (IITs \cite{forsberg-phd}) allow the mutual
definition of a type and a family of types over the first one. IITs
were originally introduced to represent the well-typed syntax of type
theory itself, and a prominent example is still Chapman's
\cite{chapman09eatitself} syntax for a type theory. A minimised version
is the IIT of contexts and types given by the following constructors.
\begin{alignat*}{5}
  & \Con && : \Set \\
  & \Ty && : \Con\ra\Set \\
  & \mathsf{empty} && : \Con \\
  & \mathsf{ext} && : (\GG:\Con)\ra\Ty\,\GG\ra\Con \\
  & \mathsf{U} && : (\GG:\Con)\ra\Ty\,\GG \\
  & \mathsf{El} && : (\GG:\Con)\ra\Ty\,(\mathsf{ext}\,\GG\,(\mathsf{U}\,\GG))
%  & \mathsf{Pi} && : (\GG:\Con)(A:\Ty\,\GG)\ra\Ty\,(\mathsf{ext}\,\GG\,A)\ra\,\Ty\,\GG
\end{alignat*}
This type has two sorts, $\Con$ and $\Ty$. The $\mathsf{ext}$ constructor of
$\Con$ refers to $\Ty$ and the $\Ty$-constructor $\mathsf{U}$ refers to $\Con$,
hence the two sorts have to be defined simultaneously. Moreover, $\Ty$ is
indexed over $\Con$. This precludes a reduction analogous to the reduction of
$\mathsf{isEven}$--$\mathsf{isOdd}$, as we would get a type indexed over
itself. Another unique feature of IITs (which also holds for higher inductive
types \cite{HoTTbook}) is that later constructors can refer to previous
constructors: in our case, $\mathsf{El}$ mentions
$\mathsf{ext}$.
% \[
%   \mathsf{Con?} : (b:\mathsf{Bool})\ra\mathsf{if}\,b\,\mathsf{then}\,\Set\,\mathsf{else}\,(\mathsf{Con?}\,\mathsf{false}\ra\Set),
% \]

The elimination principle for the above IIT has the following two
motives (one for each sort) and four methods (one for each
constructor).
\begin{alignat*}{5}
  & Con^D && : \Con\ra\Set \\
  & Ty^D && : Con^D\,\GG\ra\Ty\,\GG\ra\Set \\
  & {empty}^D && : Con^D\,\mathsf{empty} \\
  & {ext}^D && : (\GG^D:Con^D\,\GG)\ra Ty^D\,\GG^D\,A\ra Con^D\,(\mathsf{ext}\,\GG\,A) \\
  & U^D && : (\GG^D:Con^D\,\GG)\ra Ty^D\,\GG^D\,(\mathsf{U}\,\GG) \\
  & El^D && : (\GG^D:Con^D\,\GG)\ra\,Ty^D\,({ext}^D\,\GG^D\,(U^D\,\GG^D))\,(\mathsf{El}\,\GG)
%  & Pi^D && : (\GG^D:Con^D\,\GG)(A^D:\Ty^D\,\GG^D\,A)\ra \Ty^D\,(\mathsf{ext}^D\,\GG^D\,A^D)\ra\,\Ty^D\,\GG^D\,(\mathsf{Pi}\,\GG\,A\,B)
\end{alignat*}
Above we used implicit quantifications for $\GG:\Con$ and
$A:\Ty\,\GG$ to ease readability, e.g.\ $Ty^D$ has an implicit
parameter $\GG$ before its explicit parameter of type
$Con^D\,\GG$.

Given the above motives and methods the elimination principle provides
two functions
\begin{alignat*}{5}
  & \mathsf{elimCon} && : (\GG:\Con)\ra Con^D\,\GG \\
  & \mathsf{elimTy} && : (A:\Ty\,\GG)\ra Ty^D\,(\mathsf{elimCon}\,\GG)\,A
\end{alignat*}
with the following computation rules.
\begin{alignat*}{5}
  & \mathsf{elimCon}\,\mathsf{empty} && = {empty}^D \\
  & \mathsf{elimCon}\,(\mathsf{ext}\,\GG\,A) && = {ext}^D\,(\mathsf{elimCon}\,\GG)\,(\mathsf{elimTy}\,A) \\
  & \mathsf{elimTy}\,(\mathsf{U}\,\GG) && = U^D\,(\mathsf{elimCon}\,\GG) \\
  & \mathsf{elimTy}\,(\mathsf{El}\,\GG) && = El^D\,(\mathsf{elimCon}\,\GG)
\end{alignat*}
The functions $\mathsf{elimCon}$ and $\mathsf{elimTy}$ are an example
of a \emph{recursive-recursive} definition (using nomenclature from
\cite{forsberg-phd}). This means two mutually defined functions where
the type of the second function depends on the first function. The
proof assistant Agda \cite{norell07thesis} allows defining such
functions (even from non-IITs) and it is currently the only proof
assistant supporting IITs\footnote{An experimental version of Coq with
  IITs is also available on GitHub.}.

Reducing IITs to inductive types (more precisely, to indexed W-types)
is an open problem. Forsberg \cite{forsberg-phd} presented a reduction in
extensional type theory, however, this only provides a simpler,
non-recursive-recursive elimination principle. Hugunin \cite{jasper}
reduced several IITs to inductive types, working inside a cubical type
theory, but he also only constructed the simple eliminator. To
illustrate the difference, we list the motives and methods and the
simple elimination principle for the $\Con$--$\Ty$ example. Again, we
use implicit quantifications.
\begin{alignat*}{5}
  & Con^S && : \Con\ra\Set \\
  & Ty^S && : \Ty\,\GG\ra\Set \\
  & {empty}^S && : Con^S\,\mathsf{empty} \\
  & {ext}^S && : Con^S\,\GG\ra Ty^S\,\,A\ra Con^S\,(\mathsf{ext}\,\GG\,A) \\
  & U^S && : Con^S\,\GG\ra Ty^S\,(\mathsf{U}\,\GG) \\
  & El^S && : Con^S\,\GG\ra\,Ty^S\,(\mathsf{El}\,\GG) \\
  & \mathsf{selimCon} && : (\GG:\Con)\ra Con^S\,\GG \\
  & \mathsf{selimTy} && : (A:\Ty\,\GG)\ra Ty^S\,A
\end{alignat*}
This simple elimination principle is too weak, e.g.\ to define the
standard (metacircular) interpretation of our small syntax
\cite{ttintt}. Using pattern matching notation, this interpretation is
the following:
\begin{alignat*}{5}
  & \ll\blank\rr && : \Con\ra\Set_1 \\
  & \ll\blank\rr && : \ll\GG\rr\ra\Set_1 \\
  & \ll\mathsf{empty}\rr && := \top \\
  & \ll\mathsf{ext}\,\GG\,A\rr && := (\gamma:\ll\GG\rr)\times\ll A\rr\,\gamma \\
  & \ll\mathsf{U}\,\GG\rr\,\gamma && := \Set \\
  & \ll\mathsf{El}\,\GG\rr\,(\gamma,X) && := X
\end{alignat*}
The reason that we need the general elimination principle to define
$\ll\blank\rr$ is that $\ll\blank\rr$ for types refers to
$\ll\blank\rr$ for contexts, hence this function is
recursive-recursive.

Kaposi, Kov{\'a}cs, and Altenkirch
\cite{Kaposi:2019:CQI:3302515.3290315} introduced a small type theory,
 called the theory of signatures, to describe quotient
inductive-inductive types (QIIT). QIITs are generalisations of IITs
where equality constructors are also allowed. A QIIT signature is a
context in the theory of QIIT signatures, for example natural numbers
are specified by the context $(Nat:\U,zero:Nat,suc:Nat\ra Nat)$ of
length three ($Nat$, $zero$ and $suc$ are variable names). The theory
of QIIT signatures is itself a QIIT. In ibid., it is proved that if a
model of extensional type theory supports the theory of QIIT
signatures, then it supports all QIITs.

By omitting the equality type former from the theory of QIIT
signatures, we obtain a theory of IIT signatures and the construction
is still valid. It follows that if a model of extensional type theory
supports the theory of IIT signatures, it supports all IITs.

In this paper we show that any model of extensional type theory with
indexed W-types supports the theory of IIT signatures, and as a
consequence all IITs. The difficulty in this construction is that the
theory of IIT signatures is itself a QIIT, it is both
inductive-inductive and has equality constructors. However, it can be
seen as the well-typed syntax of a small type theory without any
computation rules. Hence we can represent the syntax of normal forms
without quotienting. We construct this well-typed normal syntax using
preterms and typing relations from indexed W-types. Finally, we prove
the elimination principle in the style of the initiality proof of
Streicher \cite{streichersemantics}.

Just as \cite{Kaposi:2019:CQI:3302515.3290315}, we only consider
finitary IITs, that is, constructors can only have a finite number of
recursive arguments. An example constructor for $\Con$--$\Ty$ which is
not allowed is the following:
\[
  \Pi_\infty : (\GG : \Con) \rightarrow (\mathbb{N} \rightarrow \Ty\,\GG) \rightarrow \Ty\,\GG
\]

\paragraph*{Structure of paper and list of contributions}

We describe related work in \Cref{sec:related}, and explain our
notation and Agda formalisaton in \Cref{sec:notation}. Then the
following three sections describe our three contributions:
\begin{itemize}
\item \Cref{sec:theory_of_signatures}. We define what it means for a
  model of extensional type theory (ETT, \Cref{def:ett}) to support
  all inductive-inductive types (IITs): \Cref{def:hasiits}. The novel
  contribution here is a (predicative) Church encoding of signatures
  following \cite{DBLP:conf/lics/AwodeyFS18}.
\item \Cref{sec:constructingiits}. In \Cref{thm:ToSToIITs}, we show that if a
  model of ETT supports the theory of IIT signatures
  (\Cref{def:theoryofsignatures}), then it supports IITs in the previously
  given. This is an adaptation of a proof in
  \cite{Kaposi:2019:CQI:3302515.3290315}.
\item \Cref{sec:ambroise}. Our main contribution is showing that if a
  model of ETT supports indexed W-types, then it supports the theory
  of IIT signatures (\Cref{thm:WToToS}), and hence, all IITs (\Cref{thm:WToIITs}).
\end{itemize}
We list further work in \Cref{sec:conclusions}.

The contents of this paper were presented at the TYPES 2019 conference
in Oslo \cite{types}.

\subsection{Related Work}
\label{sec:related}

The current work builds heavily on the work of Kaposi et al.\
\cite{Kaposi:2019:CQI:3302515.3290315} on finitary quotient
inductive-inductive types (QIITs); we reuse both QIIT syntax and
semantics by restricting to IITs, and we reuse the term model
construction of QIITs as well. We also make use of the extension to
infinitary QIITs \cite{large_inf_qiit} to derive the specification of
the elimination principle for the theory of IIT signatures.

IITs (although not by this name) were first used to describe the
well-typed syntax of type theory \cite{nisse,chapman09eatitself}. Agda
supported these general inductive definitions even before they were
named IITs and given semantics by Nordvall Forsberg and Setzer
\cite{nordvallforsbergSetzer2010inductiveinductive}. Nordvall
Forsberg's thesis \cite{forsberg-phd} contains a specification similar
in style to Dybjer and Setzer's codes for inductive-recursive types
\cite{Dybjer99afinite}. He also develops a categorical semantics based
on dialgebras and provides a reduction of IITs to indexed inductive
types, however only constructs the simple elimination principle as
opposed to the general one. Altenkirch et al.\ \cite{gabe} define
signatures for QIITs (thus IITs as well) and their categorical
semantics, however without proving existence of initial
algebras. Their notion of signature, like Nordvall Forsberg's,
involves more encoding overhead than ours.

Cartmell \cite{gat} introduced generalised algebraic theories using a
type-theoretic syntax. Removing equations from his signatures and only
considering finite signatures, we obtain finitary IIT signatures similar to
ours. He does not consider constructing initial algebras using simpler classes
of inductive types.

Hugunin \cite{jasper} constructs several IITs in cubical Agda from
inductive types. In this setting, the lack of UIP makes constructions
significantly more involved, and essentially involves
coinductive-coinductive well-formedness predicates defined as homotopy
limits. Hugunin does not consider a generic syntax of IITs and only
works on specific examples (although the examples vary greatly). He
also only constructs simple elimination principles.

Streicher \cite{streichersemantics} presents an interpretation of the well-formed
presyntax of a type theory into a categorical model, which is an important
ingredient in constructing an initial model, although he does not present
details on the construction of the term model or its initiality proof. Our
initiality proof can be seen as an indexed variant of his construction
(see Subsection \ref{sec:streicher} for a comparison).

Voevodsky was interested in constructing initial models of type
theories from presyntaxes. Inspired by this, Brunerie et al.\ \cite{brunerie}
formalised Streicher's proof in Agda for a type theory with $\Pi$,
$\Sigma$, $\mathbb{N}$, identity types and an infinite hierarchy of
universes. They used UIP, function extensionality and quotient types in
the formalisation. In this paper we construct a type theory without
computation rules, hence we avoid using quotients.

Intrinsic (well-typed) syntaxes for type theories were constructed using
IITs \cite{chapman09eatitself}, inductive-recursive types
\cite{nisse,Altenkirch:2014:CO:2631172.2631176} and QIITs
\cite{ttintt}. In this paper we avoid using such general classes of
inductive types as our goal is to reduce IITs to indexed inductive
types.

Reducing general classes of inductive types to simpler classes has a
long tradition in type theory. Indexed W-types were reduced to W-types
\cite{indexedcont} (using the essentially Streicher's idea of preterms
and a typing predicate), small inductive-recursive types to indexed
W-types \cite{malatasta13smallir}, mutual inductive types to indexed
W-types \cite{mutual}, W-types to natural numbers and quotients
\cite{Ahrens2019}. (Q)IITs can be reduced to quotient inductive types
using the reduction of generalised algebraic theories to essentially
algebraic theories \cite{gat}. Using the same reduction as mutual
inductive types to indexed inductive types, (Q)IITs with more than two
sorts can be reduced to (Q)IITs with only two sorts \cite{szumiemail}.

Awodey, Frey and Speight \cite{DBLP:conf/lics/AwodeyFS18} construct
inductive types using a restricted Church encoding in a type theory
with an impredicative universe. We use the predicative version of
their encoding to define IIT signatures.

Our reduction of IITs to indexed inductive types goes through two
steps: first we construct a concrete QIIT using inductive types, then
we construct all IITs from this particular QIIT. A more direct
approach is proposed by \cite{erasure}: here the initial algebra would
be constructed directly for any IIT signature without going through an
intermediate step.

\subsection{Notation and Formalisation}
\label{sec:notation}

\begin{definition}[Model of extensional type theory (ETT)]\label{def:ett}
  By a model of ETT we mean a category with families (CwF)
  \cite{Dybjer96internaltype,Hofmann97syntaxand} with a countable
  predicative hierarchy of universes closed under the following type
  formers: $\Pi$, $\Sigma$, $\top$ and an identity type with
  uniqueness of identity proofs and equality reflection.
\end{definition}

We will use Agda-like type theoretic syntax to work in the internal
language of models of ETT:
\begin{itemize}
\item Universes are written $\Set_i$. We usually omit level indices in this paper.
\item $\Pi$ types are notated as $(x : A)\ra B$, or as $A \ra B$ when
  non-dependent. We sometimes omit function arguments, by implicitly
  generalising over variables.
\item $\Sigma$-types, notated either as $(x : A)\times B$, or as
  $\sum\limits_{x} B$ when we want to leave the type of the first
  projection implicit. Projections are either named or given by
  $\proj_1$ and $\proj_2$. We use $A \times B$ for non-dependent
  pairs.
\item The unit type $\top$ has the constructor $\tt$ which is
  definitionally equal to all elements of $\top$.
\item The equality (identity) type is written $t = u$, it has a
  constructor $\refl : t = t$, and equality reflection, hence we use
  the same $=$ sign for definitional equality. We occasionally
  indicate by $_{e_1,\dots,e_n \#}t$ that $t$ is well-typed thanks to
  the equalities $e_1$,\dots,$e_n$. To construct proofs, sometimes we
  write equational reasoning, e.g. $f a \overset{e}{=} f b$ where
  $e : a = b$. We also have uniqueness of identity proofs (UIP),
  expressing $(e : t = t)\ra e = \refl$. Note that function
  extensionality, expressing $((x : A) \ra f\,x = g\,x) \ra f = g$ is
  derivable.
\end{itemize}

The contents of Section \ref{sec:ambroise} were formalised in Agda,
the formalisation is available at
\url{https://github.com/amblafont/UniversalII}. Agda's pattern
matching mechanism implies uniqueness of identity proofs, we assumed
function extensionality as an axiom and used rewrite rules
\cite{cockxsprinkles} to obtain limited equality reflection.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{A Definition of Inductive-Inductive Types}
\label{sec:theory_of_signatures}

In this section we specify what it means that a model of ETT supports
IITs. We first define the notion of IIT signature. Signatures for
algebraic theories are usually given by inductive definitions. On the
one hand, we take this even further: our notion of signature is given
by a small type theory tailor-made to describe signatures, which we call
the \emph{theory of IIT signatures}. On the other hand we would
like to avoid using a complicated inductive definition (a type theory
is a quotient inductive-inductive type \cite{ttintt}) to describe a
simpler class of inductive types. Hence we use a Church encoding
\cite{DBLP:conf/lics/AwodeyFS18} of the theory of IIT signatures, thereby
avoiding the need for pre-existing inductive definitions. Another
feature of our signatures is that they can include types from the
model of ETT (such as $\N$ in the
$\mathsf{isEven}$--$\mathsf{isOdd}$). This is why signatures are
specified internally to the particular model of ETT.\footnote{There is
  another method inspired by Capriotti \cite{paolo} which allows
  stating what it means that any CwF $\mathcal{C}$ (not necessarily a
  model of ETT) supports IITs with definitional computation rules. In
  this method, signatures are described in the internal language of
  $\hat{\mathcal{C}}$, the presheaf model over $\mathcal{C}$. We do not
  use this approach because it is more technical, and it would not
  strengthen our main result \Cref{thm:WToIITs} as the proof of
  \Cref{thm:WToToS} needs $\mathcal{C}$ to be a model of ETT.}

We define the theory of IIT signatures by saying what its algebras
(models) are. We call the \emph{theory of IIT signatures algebras}
simply \emph{signature algebras}. The theory of signatures is a small
type theory consisting of a (1) a substitution calculus (category with
families, CwF \cite{Dybjer96internaltype}) equipped with (2) a
universe, (3) a function space where the domain is in the universe and
(4) another function space with external domain. We explain the usage
of these type formers through examples after the definition.

\begin{definition}[Signature algebra, $\SignAlg$]\label{def:algebra}
  In a model of ETT, a signature algebra is an iterated $\Sigma$ type
  consisting of the following four (families of) sets, 17 operations
  and 18 equalities.
\begin{alignat*}{5}
  & \rlap{(1) Substitution calculus} \\
  & \Con && : \Set \\
  & \Ty  && : \Con\ra\Set \\
  & \Sub  && : \Con\ra\Con\ra\Set \\
  & \Tm  && : (\GG:\Con)\ra\Ty\,\GG\ra\Set \\
  & \id && : \Sub\,\GG\,\GG \\
  & \blank\circ\blank && : \Sub\,\GT\,\GD\ra\Sub\,\GG\,\GT\ra\Sub\,\GG\,\GD \\
  & \ass && : (\sigma \circ \delta) \circ \nu = \sigma \circ (\delta \circ \nu) \\
  & \idl && : \id\circ\sigma = \sigma \\
  & \idr && : \sigma\circ\id = \sigma \\
  & \blank[\blank] && : \Ty\,\GD\ra\Sub\,\GG\,\GD\ra\Ty\,\GG \\
  & \blank[\blank] && : \Tm\,\GD\,A\ra(\sigma:\Sub\,\GG\,\GD)\ra\Tm\,\GG\,(A[\sigma]) \\
  & [\id] && : A[\id] = A \\
  & [\circ] && : A[\sigma \circ \delta] = A[\sigma][\delta] \\
  & [\id] && : t[\id] = t \\
  & [\circ] && : t[\sigma \circ \delta] = t[\sigma][\delta] \\
  & \boldsymbol{\cdot} && : \Con \\
  & \epsilon && : \Sub\,\GG\,\boldsymbol{\cdot} \\
  & {\boldsymbol{\cdot}\eta} && : (\sigma : \Sub\,\GG\,\boldsymbol{\cdot}) \ra \sigma = \epsilon \\
  & \blank\ext\blank && : (\GG:\Con)\ra\Ty\,\GG\ra\Con \\
  & \blank,\blank && : (\sigma:\Sub\,\GG\,\GD)\ra\Tm\,\GG\,(A[\sigma])\ra\Sub\,\GG\,(\GD\ext A) \\
  & \pi_1 && : \Sub\,\GG\,(\GD\ext A)\ra \Sub\,\GG\,\GD \\
  & \pi_2 && : (\sigma : \Sub\,\GG\,(\GD\ext A))\ra \Tm\,\GG\,(A[\pi_1 \sigma]) \\
  & {\pi_1\beta} && : \pi_1(\sigma, t) = \sigma \\
  & {\pi_2\beta} && : \pi_2(\sigma, t) = t \\
  & {\pi\eta} && : (\pi_1\,\sigma, \pi_2\,\sigma) = \sigma \\
  & {,\circ} && : (\sigma, t)\circ\delta = (\sigma\circ\delta, t[\delta]) \\
  & \rlap{(2) Universe} \\
  & \U && : \Ty\,\GG \\
  & \El && : \Tm\,\GG\,\U\ra\Ty\,\GG \\
  & {\U[]} && : \U[\sigma] = \U \\
  & {\El[]} && : (\El\,a)[\sigma] = \El\,(a[\sigma]) \\
  & \rlap{(3) Inductive parameters} \\
  & \Pi && : (a:\Tm\,\GG\,\U)\ra\Ty\,(\GG\ext\El\,a)\ra\Ty\,\GG \\
  & \blank\oldapp\blank && : \Tm\,\GG\,(\Pi\,a\,B)\ra (u : \Tm\,\GG\,(\El\,a))
  \ra \Tm\,\GG\,(\El\,(B[\id,\,u])) \\
  & {\Pi[]} && : (\Pi\,a\,B)[\sigma] = \Pi\,(a[\sigma])\,(B[\sigma\circ\p,\q]) \\
  & {\oldapp[]} && : (t\oldapp\alpha)[\sigma] = (t[\sigma])\mathop{\oldapp}(\alpha[\sigma]) \\
  & \rlap{(4) External parameters} \\
  & \Pim && : (T:\Set)\ra(T\ra\Ty\,\GG)\ra\Ty\,\GG \\
  & \blank\appm \blank && : \Tm\,\GG\,(\Pim\,T\,B)\ra(\alpha:T) \ra\Tm\,\GG\,(B\,\alpha) \\
  & {\Pim[]} && : (\Pim\,T\,B)[\sigma] = \Pim\,T\,(\lambda \alpha.(B\,\alpha)[\sigma]) \\
  & {\appm[]} && : (t\appm\alpha)[\sigma] = (t[\sigma])\mathop{\appm}\alpha
\end{alignat*}
Given an $M:\SignAlg$, we denote its components by $\Con^M$, $\Ty^M$,
$\Sub^M$, $\Tm^M$, $\id^M$, and so on. We omit the indices if there is
only one signature algebra in scope (e.g.\ in
\Cref{def:abbrevs,ex:contexts}).
\end{definition}

\begin{definition}[Abbreviations]\label{def:abbrevs}
  For a signature algebra, we use $\wk : \Sub\,(\GG\ext A)\,\GG$
  to mean $\pi_1\,\id$. We recover de Bruijn indices by setting
  $0:= \pi_2 \,\id$ and $1+n := n[\wk]$. $\Pi\,a\,(B[\wk])$ is
  abbreviated by $a\Ra B$, $\Pim\,T\,(\lambda\_.B)$ by $T\Ram B$.
\end{definition}

\begin{example}[Example contexts in a signature algebra]\label{ex:contexts}
  Given a signature algebra, we can define a context which
  specifies natural numbers. For readability, an informal version
  of the same context is displayed on the right using variable names.
  \[
    \boldsymbol{\cdot}\,\ext\,\U\,\ext\,z : \El\,0\,\ext\,s : 1 \Ra \El\,1
    \hspace{4.9em}
    \boldsymbol{\cdot}\,\ext\,N:\U\,\ext\,z : \El\,N\,\ext\,s : N \Ra \El\,N
  \]
  We start with the empty context $\boldsymbol{\cdot}$, then we
  declare a sort $\U$, then we declare an operator producing an
  element of the sort denoted by $\El\,0$ where $0$ is the de Bruijn
  index referring to the sort. Finally, we declare an operator which
  takes as input an element of the sort (now it became de Bruijn index
  $1$) and produces an element of the same sort. Note the asymmetry of
  the function type $\Ra$: the domain needs to be an element of
  $\U$, while the codomain can be any type (including another
  function type). This ensures strict positivity of the operators.

  Lists with elements of a given $T : \Set$ type are given by the
  following context. Here we use the function space with external
  domain $\Ram$ to include a $T$ in the signature. For readability, we
  omit the $\lambda$ and the superscripts and we do not write the
  compatibility condition. On the right we list the same signature
  with variable names.
  \begin{alignat*}{10}
    & \boldsymbol{\cdot}\,\ext\,\U\,\ext\,\El\,0\,\ext\,T\Ram 1\Ra \El\,1 \hspace{3.56em} \boldsymbol{\cdot}\,\ext\,L:\U\,\ext\,nil : \El\,L\,\ext\,cons : T\Ram L\Ra \El\,L
  \end{alignat*}

  The $\Con$--$\Ty$ example from \Cref{sec:intro} is given by the
  following context.
  \begin{alignat*}{5}
    & \boldsymbol{\cdot} \,\ext                                                 && \boldsymbol{\cdot} \,\ext                                                                \\
    & \U\,\ext                                                                  && Con && : \U\,\ext                                                                        \\
    & 0\Ra\U\,\ext                                                              && Ty && : Con\Ra\U\,\ext                                                                   \\
    & \El\,1\,\ext                                                              && empty && : \El\,Con\,\ext                                                                \\
    & \Pi\,2\,(2\oldapp 0 \Ra \El\,3)\ext                                       && ext && : \Pi\,(\GG : Con)\,(Ty\oldapp\GG \Ra \El\,Con)\ext                         \\
    & \Pi\,3\,(\El\,(3\oldapp 0))\,\ext                                         && U && : \Pi\,(\GG:Con)\,(\El\,(Ty\oldapp\GG))\,\ext                                 \\
    & \Pi\,4\,(\El\,(4\oldapp(2\oldapp 0\oldapp (1\oldapp 0)))) \hspace{4.79em} && El && : \Pi\,(\GG : Con)\,(\El\,(Ty\oldapp(ext\oldapp\GG\oldapp (U\oldapp\GG))))
  \end{alignat*}
\end{example}

The above examples are contexts in any signature algebra, and we could
take this as a definition of signature: $(M:\SignAlg)\ra\Con^M$ is the
usual Church-encoding of contexts. However (as we will see in
\Cref{remark:sigc}) the notion of constructor for such signatures
would be too strong. Another approach would be to assume that there is
a syntax for signature algebras (an initial signature algebra), and
then a signature would be a context in this signature algebra. We will
define syntactic signatures using this approach in the next section
(\Cref{def:syntacticsignature}), but for now we do not want to assume
the existence of any inductive type. Instead, we will use a restricted
Church encoding. This requires the notion of morphism of signatures.

The notion of morphism is determined by the notion of algebra
\cite{large_inf_qiit}, but we include it here for completeness.
\begin{definition}[Signature morphism, $\SignMor$]\label{def:morphism}
  A morphism from signature algebras $M$ to $N$ denoted
  $\SignMor\,M\,N$ consists of four functions and 17 equalities
  expressing that the functions preserve the operations of the two
  algebras. We use the same naming as in \Cref{def:algebra} and use
  superscripts to denote which algebra is meant.
\begin{alignat*}{5}
  & \rlap{(1) Substitution calculus} \\
  & \Con && : \Con^M && \ra\Con^N \\
  & \Ty  && : \Ty^M\,\GG && \ra\Ty^N\,(\Con\,\GG) \\
  & \Sub  && : \Sub^M\,\GG\,\GD && \ra\Sub^N(\Con\,\GG)\,(\Con\,\GD) \\
  & \Tm  && : \Tm^M\,\GG\,A && \ra\Tm^N\,(\Con\,\GG)\,(\Ty\,A) \\
  & \id && : \Sub\,\id^M && = \id^N \\
  & {\circ} && : \sigma\circ^M\delta && = \Sub\,\sigma\circ^N\Sub\,\delta \\
  & [] && : A[\sigma]^M && = \Ty\,A[\Sub\,\sigma]^N \\
  & [] && : t[\sigma]^M && = \Tm\,t[\Sub\,\sigma]^N \\
  & \boldsymbol{\cdot} && : \Con\,\boldsymbol{\cdot}^M && = \boldsymbol{\cdot}^N \\
  & \epsilon && : \Sub\,\epsilon^M && = \epsilon^N \\
  & \ext && : \Con\,(\GG\ext^M A) && = \Con\,\GG\ext^N\Ty\,A \\
  & , && : \Sub\,(\sigma,^M t) && = \Sub\,\sigma ,^N\Tm\,t \\
  & \pi_1 && : \Sub\,({\pi_1}^M\,\sigma) && = {\pi_1}^N\,(\Sub\,\sigma) \\
  & \pi_2 && : \Tm\,({\pi_2}^M\,\sigma) && = {\pi_2}^N\,(\Sub\,\sigma) \\
  & \rlap{(2) Universe} \\
  & \U && : \Ty\,\U^M && = \U^N \\
  & \El && : \Ty\,(\El^M\,a) && = \El^N\,(\Tm\,a) \\
  & \rlap{(3) Inductive parameters} \\
  & \Pi && : \Ty\,(\Pi^M\,a\,B) && = \Pi^N\,(\Tm\,a)\,(\Ty\,B) \\
  & \oldapp && : \Tm\,(t\mathbin{{\oldapp}^M} u) && = \Tm\,t\mathbin{{\oldapp}^N}\,\Tm\,u \\
  & \rlap{(4) External parameters} \\
  & \Pim && : \Ty\,(\Pim^M\,T\,B) && = \Pim^N\,T\,(\lambda\alpha.\Ty\,(B\,\alpha)) \\
  & \appm && : \Tm\,(t\mathbin{{\appm}^M}\alpha) && = \Tm\,t\mathbin{{\appm}^N}\alpha
\end{alignat*}
Given an $f:\SignMor\,M\,N$, we denote its first four components just
by $f_\Con$, $f_\Ty$, $f_\Sub$, $f_\Tm$ or just write $f$ if it is
clear which one is meant.
\end{definition}

We define IIT signatures using the Church encoding introduced by Awodey, Frey
and Speight \cite{DBLP:conf/lics/AwodeyFS18}. A difference is that we avoid
impredicativity. This restricts the possible eliminations on signatures: we can
only eliminate into a universe which is smaller than the level of
signatures. However, this still covers all eliminations in this paper, and it is
also not an issue for us that signatures do not live in the smallest universe.

%% We define IIT signatures using the Church encoding introduced by
%% Awodey, Frey and Speight \cite{DBLP:conf/lics/AwodeyFS18}. A
%% difference is that we avoid the usage of impredicativity because it is
%% not a problem for our use case that signatures are not in the lowest
%% universe.
\begin{definition}[IIT signature]\label{defn:sign}
  An IIT signature is a context in an arbitrary signature algebra, which is also
  compatible with morphisms:
  \begin{alignat*}{6}
    & \Sign :=\,\, && \big({sig}:(M:\SignAlg)\ra\Con^M\big)\times \\
    & && \big((M\,N:\SignAlg)(f:\SignMor\,M\,N)\ra f_\Con\,({sig}\,M) = {sig}\,N \big).
  \end{alignat*}
\end{definition}
The compatibility condition says that if we obtain an $M$-context
using ${sig}$ in model $M$ and then we transport it to $N$ using $f$,
we get the same $N$-context as directly applying ${sig}$ to $N$.

The lack of impredicativity implies that our notion of signatures do not form a
signature algebra.
\begin{lemma}
  There is no $M : \SignAlg$, in which $\Con^M = \Sign$.
\end{lemma}
\begin{proof}
  If the $\Con$ component in $\SignAlg$ is $\Set_i$, then $\SignAlg$
  is in $\Set_{i+1}$, but as $\Sign$ is defined as
  $(\SignAlg\ra\dots)\times\dots$, it is at least in $\Set_{i+1}$, so
  we can't choose $\Con^M : \Set_i$ to be $\Sign : \Set_{i+1}$.
\end{proof}

Note that the notion of IIT signature is relative to a model of ETT:
it is expressed as a term (of a function type) in the model. This is
necessary because of the function space $\Pim$, which has as domain an
arbitrary type in the model. We make use of $\Pim$ in signatures with
external parameters, like the type of the elements in lists.

\begin{example}[Example signature]\label{ex:signatures}
  Now we can formally describe the contexts given in
  \Cref{ex:contexts} as signatures. For natural numbers, we have the
  following pair of functions. The second function returns an equality
  proof which we describe using equational reasoning.
  \begin{alignat*}{5}
    & \rlap{$(nat,natc) := $} \\
    & \hspace{1em} && \big( && \rlap{$\lambda M.(\boldsymbol{\cdot}^M\,\ext^M\,\U^M\,\ext^M\,\El^M\,0^M\,\ext^M\,1^M \Ra^M \El^M\,1^M),$} \\
    & && && \lambda M\,N\,f\,.\, && f_\Con\,(\boldsymbol{\cdot}^M\,\ext^M\,\U^M\,\ext^M\,\El^M\,0^M\,\ext^M\,1^M \Ra^M \El^M\,1^M) = \\
    & && && && f_\Con\,(\boldsymbol{\cdot}^M\,\ext^M\,\U^M\,\ext^M\,\El^M\,0^M)\ext^N f_\Ty\,(1^N\Ra^N \El^N\,1^N) = \\
    & && && && f_\Con\,(\boldsymbol{\cdot}^M\,\ext^M\,\U^M)\,\ext^N\,f_\Ty\,(\El^M\,0^M)\ext^N f_\Tm\,1^N\Ra^M f_\Ty\,(\El^N\,1^N) = \\
    & && && && f_\Con\,\boldsymbol{\cdot}^M\,\ext^N\,f_\Ty\,\U^M\,\ext^N\,\El^N\,(f_\Tm\,0^M)\ext^N 1^M\Ra^M \El^M\,(f_\Tm\,1^N) = \\
    & && && && \boldsymbol{\cdot}^N\,\ext^N\,\U^N\,\ext^N\,\El^N\,0^N\,\ext^N\,1^N \Ra^N \El^N\,1^N \big)
  \end{alignat*}
  The first component builds the context describing natural numbers in
  $M$, the second one uses the fact that $f$ is a morphism, that is,
  it preserves all operations.

  The signatures for lists and $\Con$--$\Ty$ can be given analogously.
\end{example}

Given a model of ETT and an IIT signature in it, we would like to say
what it means that the model supports the given IIT. For this we
define the signature algebra $\ADS$ which will provide notions of
algebras, displayed algebras and sections for each signature. This is
the same as the $\blank^\A$, $\blank^\D$ and $\blank^\S$ operations in
\cite{Kaposi:2019:CQI:3302515.3290315}. Before defining $\ADS$, we
illustrate its usage by an example.

\begin{example}[Algebras, displayed algebras and sections for natural
  numbers]\label{ex:adsnat}
  For the signature of natural numbers as given in
  \Cref{ex:signatures}, algebras are given by the $\Sigma$-type
  $(N:\Set)\times N\times(N\ra N)$. A displayed algebra over $(N,z,s)$
  is given by the $\Sigma$-type
  \[
    (N^D:N\ra\Set)\times N^D\,z \times((n:N)\ra N^D\,n\ra N^D\,(s\,n)),
  \]
  and a section of a displayed algebra $(N^D,z^D,s^D)$ over $(N,z,s)$
  is given by the $\Sigma$-type
  \[
    (N^S:(n:N)\ra N^D\,n)\times (N^S\,z = z^D) \times((n:N)\ra N^S\,(s\,n) = s^D\,n\,(N^S\,n)).
  \]
  Displayed algebras over the initial algebra are called motives and
  methods of the eliminator, while a section of a displayed algebra
  over the initial algebra is the eliminator together with its
  computation rules.
\end{example}

\begin{definition}[The signature algebra $\ADS$]\label{def:ads}
  We define an element of $\SignAlg$ by listing all its components
  $\Con$, $\Ty$, $\Sub$, and so on, one per row. Each such component
  has three parts denoted by $^\A$, $^\D$ and $^\S$, respectively. The
  equality components of $\SignAlg$ are omitted as they are all
  reflexivity.
  \begin{alignat*}{10}
    & (\GG^\A:\Set) && \hspace{-0.3em}\times && (\GG^\D:\GG^\A\ra\Set) && \hspace{-0.3em}\times && (\GG^\S:(\gamma:\GG^\A)\ra\GG^\D\,\gamma\ra\Set) \\
    & (A^\A:\GG^\A\ra\Set) && \hspace{-0.3em}\times && (A^\D:\GG^\D\,\gamma\ra A^\A\,\gamma\ra\Set) && \hspace{-0.3em}\times && (A^\S:\GG^\S\,\gamma\,\gamma^D\ra(\alpha:A^\A\,\gamma)\ra \\
    & && && && && \hspace{1em} A^\D\,\gamma^D\,\alpha\ra\Set) \\
    & (\sigma^\A:\GG^\A\ra\GD^\A) && \hspace{-0.3em}\times && (\sigma^\D:\GG^\D\,\gamma\ra\GD^\D\,(\sigma^\A\,\gamma)) && \hspace{-0.3em}\times && (\sigma^\S:\GG^\S\,\gamma\,\gamma^D\ra \\
    & && && && && \hspace{1em} \GD^\S\,(\sigma^\A\,\gamma)\,(\sigma^\D\,\gamma^D)) \\
    & (t^\A:(\gamma:\GG^\A)\ra A^\A\,\gamma) && \hspace{-0.3em}\times && (t^\D:(\gamma^D:\GG^\D\,\gamma)\ra && \hspace{-0.3em}\times && (t^\S:(\gamma^S:\GG^\S\,\gamma\,\gamma^D)\ra \\
    & && && \hspace{1em} A^\D\,\gamma^D\,(t^\A\,\gamma)) && && \hspace{1em}  A^\S\,(t^\A\,\gamma)\,(t^\D\,\gamma^D)) \\
    & \id^\A\,\gamma := \gamma && && \id^\D\,\gamma^D:=\gamma^D && && \id^\S\,\gamma^S := \gamma^S \\
    & (\sigma\circ\delta)^\A\,\gamma := \sigma^\A\,(\delta^\A\,\gamma) && && (\sigma\circ\delta)^\D\,\gamma^D := \sigma^\D\,(\delta^\D\,\gamma^D) && && (\sigma\circ\delta)^\S\,\gamma^S := \sigma^\S\,(\delta^\S\,\gamma^S) \\
    & (A[\sigma])^\A\,\gamma := A^\A\,(\sigma^\A\,\gamma) && && (A[\sigma])^\D\,\gamma^D := A^\D\,(\sigma^\D\,\gamma^D) && && (A[\sigma])^\S\,\gamma^S := A^\S\,(\sigma^\S\,\gamma^S) \\
    & (t[\sigma])^\A\,\gamma := t^\A\,(\sigma^\A\,\gamma) && && (t[\sigma])^\D\,\gamma^D := t^\D\,(\sigma^\D\,\gamma^D) && && (t[\sigma])^\S\,\gamma^S := t^\S\,(\sigma^\S\,\gamma^S) \\
    & \cdot^\A := \top && && \cdot^\D\,\_ := \top && && \cdot^\S\,\_\,\_ := \top \\
    & \epsilon^\A\,\_ := \tt && && \epsilon^\D\,\_ := \tt && && \epsilon^\S\,\_ := \tt \\
    & (\GG\rhd A)^\A := && && (\GG\rhd A)^\D\,(\gamma,\alpha) :=  && && (\GG\rhd A)^\S\,(\gamma,\alpha)\,(\gamma^D,\alpha^D) := \\
    & \hspace{1em} (\gamma:\GG^\A)\times A^\A\,\gamma && && \hspace{1em} (\gamma^D:\GG^\D\,\gamma)\times A^\D\,\gamma^D\,\alpha && && \hspace{1em} (\gamma^S:\GG^\S\,\gamma\,\gamma^D)\times A^\S\,\gamma^S\,\alpha\,\alpha^D \\
    & (\sigma,t)^\A\,\gamma := (\sigma^\A\,\gamma,t^\A\,\gamma) && && (\sigma,t)^\D\,\gamma^D := (\sigma^\D\,\gamma^D,t^\D\,\gamma^D) && && (\sigma,t)^\S\,\gamma^S := (\sigma^\S\,\gamma^S,t^\S\,\gamma^S) \\
    & (\pi_1\,\sigma)^\A\,\gamma := \proj_1\,(\sigma^\A\,\gamma) && && (\pi_1\,\sigma)^\D\,\gamma^D := \proj_1\,(\sigma^\D\,\gamma^D) && && (\pi_1\,\sigma)^\S\,\gamma^S := \proj_1\,(\sigma^\S\,\gamma^S) \\
    & (\pi_2\,\sigma)^\A\,\gamma := \proj_2\,(\sigma^\A\,\gamma) && && (\pi_2\,\sigma)^\D\,\gamma^D := \proj_2\,(\sigma^\D\,\gamma^D) && && (\pi_2\,\sigma)^\S\,\gamma^S := \proj_2\,(\sigma^\S\,\gamma^S) \\
    & \U^\A\,\gamma := \Set && && \U^\D\,\gamma^D\,T := T\ra\Set && && \U^\S\,\gamma^S\,T\,T^D := (\alpha:T)\ra T^D\,\alpha \\
    & (\El\,a)^\A\,\gamma := a^\A\,\gamma && && (\El\,a)^\D\,\gamma^D\,\alpha := a^\D\,\gamma^D\,\alpha && && (\El\,a)^\S\,\gamma^S\,\alpha\,\alpha^D := (a^\S\,\gamma^S\,\alpha = \alpha^D) \\
    & (\Pi\,a\,B)^\A\,\gamma := && && (\Pi\,a\,B)^\D\,\gamma^D\,f := && && (\Pi\,a\,B)^\S\,\gamma^S\,f\,f^D := (\alpha:a^\A\,\gamma)\ra \\
    & \hspace{1em} (\alpha:a^\A\,\gamma)\ra B^\A\,(\gamma,\alpha) && && \hspace{1em}  (\alpha^D:a^\D\,\gamma^D\,\alpha)\ra && && \hspace{1em} B^\S\,(\gamma^S,\refl_{a^\S\,\gamma^S\,\alpha})\,(f\,\alpha)\,\\
    & && && \hspace{1em}  B^\D\,(\gamma^D,\alpha^D)\,(f\,\alpha) && && \hspace{1em}\hphantom{B^\S\,}(f^D\,(a^\S\,\gamma^S\,\alpha)) \\
    & (t\oldapp u)^\A\,\gamma := t^\A\,\gamma\,(u^\A\,\gamma) && &&  (t\oldapp u)^\D\,\gamma^D := t^\D\,\gamma^D\,(u^\D\,\gamma^D) && &&  (t\oldapp u)^\S\,\gamma^S := _{u^\S\,\gamma^S \#} t^\S\,\gamma^\S\,(u^\A\,\gamma) \\
    & (\Pim\,T\,B)^\A\,\gamma := && && (\Pim\,T\,B)^\D\,\gamma^D\,f := && && (\Pim\,T\,B)^\S\,\gamma^S\,f\,f^D := (\alpha:T)\ra \\
    & \hspace{1em} (\alpha:T)\ra(B\,\alpha)^\A\,\gamma && && \hspace{1em} (\alpha:T)\ra(B\,\alpha)^\D\,\gamma^D\,(f\,\alpha) && && \hspace{1em} (B\,\alpha)^\S\,\gamma^S\,(f\,\alpha)\,(f^D\,\alpha) \\
    & (t\appm \alpha)^\A\,\gamma := t^\A\,\gamma\,\alpha && && (t\appm \alpha)^\D\,\gamma^D := t^\D\,\gamma^D\,\alpha && && (t\appm \alpha)^\S\,\gamma^S := t^\S\,\gamma^S\,\alpha
  \end{alignat*}
\end{definition}
\Cref{def:ads} can be explained by columns (see
\cite[Sections 4 and 6]{Kaposi:2019:CQI:3302515.3290315} for more details) or by rows
(see \cite[Section 7.4]{Kaposi:2019:CQI:3302515.3290315}).

We first explain it by columns: the first column ($^\A$ components)
corresponds to the standard model (set model, metacircular
interpretation \cite{ttintt}): contexts are sets, types are families,
terms are functions, the universe $\U$ is given by $\Set$, function
spaces are given by the external function space. The $^\D$ column is a
logical predicate interpretation, $^\A$ and $^\D$ together are a unary
version of the parametric model for dependent types
\cite{10.1145/2535838.2535852}. Contexts are predicates, types are
families of predicates, terms say that the $^\A$ interpretation
respects the predicates (this is ususally called fundamental lemma of
the logical predicate). $\U$ is given by predicate space, the
predicate at a $\Pi$ type holds for a function if it respects the
predicates. For $\Pim$, the predicate is defined pointwise. The last
column $^\S$ is a modified dependent logical relation which refers to
both $^A$ and $^\D$. Contexts are binary relations where the second
parameter depends on the first one, types are dependent variants of
this, terms say that the relation is respected by $^\A$ and $^\D$,
respectively. $\U$ is however not relation space, but a function and
$(\El\,a)^\S$ is the graph of the function $a^\S$. $\Pi^\S$ for a
function again says that the function respects the relation, however
we do not simply say
\[
  (\Pi\,a\,B)^\S\,\gamma^S\,f\,f^D := (\alpha:a^\A\,\gamma)(\alpha^D:a^\D\,\gamma^D\,\alpha)(\alpha^\S:(\El\,a)^\S\,\gamma^S\,\alpha\,\alpha^D)\ra B^\S\,\dots,
\]
as $(\El\,a)^\S\,\gamma^S\,\alpha\,\alpha^D$ is just an equality
$a^\S\,\gamma^S\,\alpha = \alpha^D$ which we can singleton
contract. So we omit $\alpha^D$ and this equality as an input and
replace $\alpha^D$ by $a^\S\,\gamma^S\,\alpha$ in the definition.

When viewing $\ADS$ by rows, we can see that it is a part of the CwF
model of type theory \cite[Section
7.4]{Kaposi:2019:CQI:3302515.3290315}. In the CwF model, a context is
given by a CwF. Now, from the category part of the CwF, we only have
objects ($\GG^\A$), and from the families, we have the families for
types $\GG^\D$ and terms $\GG^\S$. Types are the corresponding
parts of displayed CwFs, substitutions are parts of CwF morphisms,
terms are parts of CwF sections. $\U$ is part of the CwF of sets,
$\El\,a$ is the part of the discrete displayed CwF coming from $a$
(which is a CwF-morphism from $\GG$ to the CwF of sets). $\Pi$ is
given by a dependent product of displayed CwFs where it is essential
that the domain is discrete, $\Pim$ is the pointwise direct product.

\begin{definition}[The set signature algebra $\A$]\label{def:a}
  $\A : \SignAlg$ is given by the first $^\A$ components of $\ADS$
  (\Cref{def:ads}), that is, $\Con^\A := \Set$,
  $\Ty^\A\,\GG := \GG\ra\Set$,
  $\Sub^\A\,\GG\,\GD := \GG\ra\GD$, and so on. There is a
  morphism from $\ADS$ to $\A$ defined by $\blank^\A$ at each
  component, which we also denote by $\blank^\A : \SignMor\,\ADS\,\A$.
\end{definition}

\begin{definition}[A model of ETT supports IITs]\label{def:hasiits}
  A model of ETT supports IITs if for any signature $(sig,sigc):\Sign$
  there is a
  \[
    \con_{sig}: ({sig}\,\ADS)^\A
  \]
  and an
  \[
    \elim_{sig} : (\gamma^D:({sig}\,\ADS)^\D\,\con_{sig})\ra ({sig}\,\ADS)^\S\,\con_{sig}\,\gamma^D.
  \]
\end{definition}
In other words, for any signature, we have an algebra called $\con$
(constructors) and for any displayed algebra over the constructors, we
have a section (called the eliminator).

One can check that \Cref{def:hasiits} gives the right
notion of constructors and elimination principle for the signatures in
\Cref{ex:signatures}.
\begin{example}[A model of ETT supports natural numbers]
  For the signature $({nat},{natc})$ of natural numbers in
  \Cref{ex:signatures}, the type of $\con_{nat}$ is
  \begin{alignat*}{5}
    & ({nat}\,\ADS)^\A = \\
    & (\boldsymbol{\cdot}^\ADS\,\ext^\ADS\,\U^\ADS\,\ext^\ADS\,\El^\ADS\,0^\ADS\,\ext^\ADS\,1^\ADS \Ra^\ADS \El^\ADS\,1^\ADS)^\A = \\
    & \Big(\big((\boldsymbol{\cdot}\,\ext\,\U)\,\ext\,\El\,(\pi_2\,\id)\big)\,\ext\,\big(\pi_2\,(\pi_1\,\id)\big) \Ra \El\,\big(\pi_2\,(\pi_1\,\id)\big)\Big)^\A = \\
    & \Big(\gamma'':\big(\gamma':((\gamma:\boldsymbol{\cdot}^\A)\times \U^\A\,\gamma)\big)\times (\El\,(\pi_2\,\id))^\A\,\gamma'\Big)\times\Big(\Pi\,\big(\pi_2\,(\pi_1\,\id)\big)\,\big(\pi_2\,(\pi_1\,(\pi_1\,\id))\big)\Big)^\A\,\gamma'' = \\
    & \Big(\gamma'':\big(\gamma':((\gamma:\top)\times\Set)\big)\times(\proj_2\,\gamma')\Big)\times\big(\proj_2\,(\proj_1\,\gamma'')\ra\proj_2\,(\proj_1\,\gamma'')\big),
  \end{alignat*}
  which is a left-nested $\Sigma$ type isomorphic to its
  right-nested counterpart
  \[
    (N:\Set)\times \big(N \times (N\ra N)\big).
  \]
  Writing $(((\tt,\mathsf{Nat}),\mathsf{zero}),\mathsf{suc})$ for
  $\con_{nat}$, the type of $\elim_{nat}$ computes as follows.
  \begin{alignat*}{5}
    & \rlap{$(\gamma^D: ({nat}\,\ADS)^\D\,\con_{nat})\ra ({nat}\,\ADS)^\S\,\con_{nat}\,\gamma^D =$} \\
    & \rlap{$\bigg(\gamma^D: \Big( \big((\boldsymbol{\cdot}\,\ext\,\U)\,\ext\,\El\,(\pi_2\,\id)\big)\,\ext\,\big(\pi_2\,(\pi_1\,\id)\big) \Ra \El\,\big(\pi_2\,(\pi_1\,\id)\big)\Big)^\D\,\con_{nat}\bigg)\ra$} \\
    & \rlap{$\Big( \big((\boldsymbol{\cdot}\,\ext\,\U)\,\ext\,\El\,(\pi_2\,\id)\big)\,\ext\,\big(\pi_2\,(\pi_1\,\id)\big) \Ra \El\,\big(\pi_2\,(\pi_1\,\id)\big)\Big)^\S\,\con_{nat}\,\gamma^D =$} \\
    & \rlap{$\bigg(\gamma^D: \Big( \big((\boldsymbol{\cdot}\,\ext\,\U)\,\ext\,\El\,(\pi_2\,\id)\big)\,\ext\,\big(\pi_2\,(\pi_1\,\id)\big) \Ra \El\,\big(\pi_2\,(\pi_1\,\id)\big)\Big)^\D\,$} \\
    & \rlap{$\hspace{1em} \big(((\tt,\mathsf{Nat}),\mathsf{zero}),\mathsf{suc}\big)\bigg)\ra$} \\
    & \rlap{$\Big(\big((\boldsymbol{\cdot}\,\ext\,\U)\,\ext\,\El\,(\pi_2\,\id)\big)\,\ext\,\big(\pi_2\,(\pi_1\,\id)\big) \Ra \El\,\big(\pi_2\,(\pi_1\,\id)\big)\Big)^\S\,\big(((\tt,\mathsf{Nat}),\mathsf{zero}),\mathsf{suc}\big)\,\gamma^D = $} \\
    & \bigg(\big(((\tt,N^D),z^D),s^D\big): && \Big( {\gamma^D}'':\big({\gamma^D}':((\gamma^D:\boldsymbol{\cdot}^\D\,\tt)\times \U^\D\,\gamma^D\,\mathsf{Nat})\big)\times (\El\,(\pi_2\,\id))^\D\,{\gamma^D}'\,\mathsf{zero}\Big)\times \\
    & && \Big(\Pi\,\big(\pi_2\,(\pi_1\,\id)\big)\,\big(\pi_2\,(\pi_1\,(\pi_1\,\id))\big)\Big)^\D\,{\gamma^D}''\,\mathsf{suc}\bigg)\ra \\
    & \rlap{$ \Big(\big((\boldsymbol{\cdot}\,\ext\,\U)\,\ext\,\El\,(\pi_2\,\id)\big)\,\ext\,\big(\pi_2\,(\pi_1\,\id)\big) \Ra \El\,\big(\pi_2\,(\pi_1\,\id)\big)\Big)^\S\,(((\tt,\mathsf{Nat}),\mathsf{zero}),\mathsf{suc})\,$} \\
    & \rlap{$\hspace{1em} \big(((\tt,N^D),z^D),s^D\big) =$} \\
    & \bigg(\big(((\tt,N^D),z^D),s^D\big): && \Big( {\gamma^D}'':\big({\gamma^D}':((\gamma^D:\boldsymbol{\cdot}^\D\,\tt)\times \U^\D\,\gamma^D\,\mathsf{Nat})\big)\times (\El\,(\pi_2\,\id))^\D\,{\gamma^D}'\,\mathsf{zero}\Big)\times \\
    & && \Big(\Pi\,\big(\pi_2\,(\pi_1\,\id)\big)\,\big(\pi_2\,(\pi_1\,(\pi_1\,\id))\big)\Big)^\D\,{\gamma^D}''\,\mathsf{suc}\bigg)\ra \\
    & \rlap{$ \Big( {\gamma^S}'':\big({\gamma^S}':((\gamma^S:\boldsymbol{\cdot}^\S\,\tt\,\tt)\times \U^\S\,\gamma^S\,\mathsf{Nat}\,N^D)\big)\times (\El\,(\pi_2\,\id))^\S\,{\gamma^S}'\,\mathsf{zero}\,z^D\Big)\times$} \\
    & \rlap{$ \Big(\Pi\,\big(\pi_2\,(\pi_1\,\id)\big)\,\big(\pi_2\,(\pi_1\,(\pi_1\,\id))\big)\Big)^\S\,{\gamma^S}''\,\mathsf{suc}\,s^D = $} \\
    & \bigg(\big(((\tt,N^D),z^D),s^D\big): && \Big( {\gamma^D}'':\big({\gamma^D}':((\gamma^D:\top)\times (\mathsf{Nat}\ra\Set))\big)\times \proj_2\,{\gamma^D}'\,\mathsf{zero}\Big)\times \\
    & && \big(\proj_2\,(\proj_1\,{\gamma^D}'')\,n\ra\proj_2\,(\proj_1\,{\gamma^D}'')\,(\mathsf{suc}\,n)\big)\bigg)\ra \\
    & \rlap{$ \Big( {\gamma^S}'':\big({\gamma^S}':((\gamma^S:\top)\times ((n:\mathsf{Nat})\ra N^D\,n))\big)\times \proj_2\,{\gamma^S}'\,\mathsf{zero} = z^D\Big)\times$} \\
    & \rlap{$ \Big(\big(n:\mathsf{Nat}\big)\ra\proj_2\,(\proj_1\,(\proj_1\,{\gamma^S}''))\,(\mathsf{suc}\,n) = s^D\,\big(\proj_2\,(\proj_1\,(\proj_1\,{\gamma^S}''))\,n\big)\Big)$}
  \end{alignat*}
  This is again a left-nested version of the expected elimination
  principle
  \begin{alignat*}{10}
    & (N^D:\mathsf{Nat}\ra\Set)(z^D:N^D\,\mathsf{zero})\big(s^D:(n:\mathsf{Nat})\ra N^D\,n\ra N^D\,(\mathsf{suc}\,n)\big)\ra \\
    & \big(N^S:(n:\mathsf{Nat})\ra N^D\,n\big)\times(N^S\,\mathsf{zero} = z^D)\times \big((n:\mathsf{Nat})\ra N^S\,(\mathsf{suc}\,n) = s^D\,(N^S\,n)\big)
  \end{alignat*}
\end{example}
\begin{remark}
  The computation rules of the elimination principle are only expected
  up to the internal equality type, but as we work with a model of
  ETT, we also get them as definitional equalities by equality
  reflection.
\end{remark}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Constructing all IITs from the Theory of IIT Signatures}
\label{sec:constructingiits}

In the previous section, using the notions of signature algebras and
signature morphisms, we defined IIT signatures and what it means for a
model of ETT to support all IITs. In this section we show that if a
model of ETT supports the theory of IIT signatures, then it supports
all IITs. Using the Church encoding of \Cref{defn:sign},
every model of ETT can describe ITT signatures. In contrast, in
\Cref{def:theoryofsignatures}, we will require existence of an initial
signature algebra.

The contents of this section are an adjustment of \cite[Sections 4 and
6]{Kaposi:2019:CQI:3302515.3290315} to our setting.

\begin{definition}\label{def:theoryofsignatures}
  A model of ETT supports the theory of IIT signatures if there is a
  signature algebra $\I : \SignAlg$ equipped with a unique morphism
  $\ll\blank\rr_{M} : \SignMor\,\I\,M$ into any algebra $M$. Sometimes
  we omit the subscript $_M$. We call $\I$ the syntax or initial
  algebra, the morphism $\ll\blank\rr$ is called recursor.
\end{definition}

\begin{definition}[Syntactic signatures]\label{def:syntacticsignature}
  In a model of ETT supporting the theory of ITT signatures, we call
  elements of $\Con^\I$ syntactic signatures.
\end{definition}

One may wonder what is the relationship between the two notion of
signatures.
\begin{lemma}
  In a model of ETT supporting the theory of ITT signatures,
  signatures and syntactic signatures are isomorphic.
\end{lemma}
\begin{proof}
  We can turn a $({sig},{sigc}) : \Sign$ into $\Con^\I$ by ${sig}\,\I$
  and an $\GO:\Con^\I$ into a $\Sign$ by
  $\Big(\lambda M.\ll\GO\rr_M, \lambda M\,N\,f.\big(f\,\ll\GO\rr_M =
  (f\circ\ll\blank\rr_M)\,\GO = \ll\GO\rr_N\big)\Big)$ where the equality
  proof in the second component comes from uniqueness of the recursor
  (we have to define composition of morphisms $\circ$ for this). The
  compositions of these two maps are the identities: $({sig},{sigc})$
  is mapped to
  $(\lambda M.\ll{sig}\,I\rr_M,\dots) = (\lambda
  M.\ll\blank\rr_M\,({sig}\,I),\dots)$ which is equal to
  $(\lambda M.{sig}\,M,\dots)$ because of ${sigc}$; $\GO$ is mapped
  to $\ll\GO\rr_\I = \GO$ by uniqueness of $\ll\blank\rr$.
\end{proof}

We will define the term signature algebra by which we obtain the constructors
$\con$ for any IIT signature. Then we will define another signature algebra
which provides the eliminator. Before doing these, we illustrate the idea of
both constructions on natural numbers.
\begin{example}\label{eg:nat_con}
  For natural numbers, we will define the constructors $\con$ as the
  following natural number algebra
  $(\mathsf{Nat},\mathsf{zero},\mathsf{suc})$. We write variable names
  instead of de Bruijn indices for readability.
  \begin{alignat*}{5}
    & \mathsf{Nat} && := \Tm^\I\,(\cdot\rhd N:\U\rhd z:\El\,N\rhd s:N\Ra\El\,N)\,(\El\,N) \\
    & \mathsf{zero} && := z \\
    & \mathsf{suc} && := \lambda t. (s\oldapp t)
  \end{alignat*}
  Natural numbers are simply $\I$-terms of type $\El\,N$ in the
  context which is the syntactic signature for natural numbers. In
  this context, the only way to define a term of type $\El\,N$ is to
  use $z$ and $s$, corresponding to the $\mathsf{zero}$ and
  $\mathsf{suc}$ constructors.

  To define the action of the eliminator on a natural number
  $n : \mathsf{Nat}$, let's look at the type of the displayed algebra
  interpretation of the number:
  \[
    {\ll n \rr_\ADS}^\D : (\gamma^D : \ll\cdot\rhd N:\U\rhd z:\El\,N\rhd s:N\Ra\El\,N\rr^\D\,\con) \ra \ll\El\,N\rr^\D\,(\ll n\rr^\A\,\con)
  \]
  This says that for a displayed algebra $\gamma^D=(N^D,z^D,s^D)$ over
  $\con$ (i.e.\ the motives and methods of the eliminator), we get a
  witness of the predicate $\ll\El\,N\rr^\D = N^D$ at the algebra
  interpretation of $n$. This is not yet good, as we would like to get
  $N^D\,n$ instead of $N^D\,(\ll n\rr^\A\,\con)$ as a result. However,
  interpretation into the term signature algebra will imply that
  $n = \ll n\rr^\A\,\con$.
\end{example}

\begin{definition}[Term signature algebra $\IC_{\blank}$]
  For an $\GO:\Con^I$, we define $\IC_\GO:\SignAlg$ which we
  call the term signature algebra. It is equipped with a morphism
  $\blank^\I : \SignMor\,(\IC_\GO)\,\I$. We define $\IC_{\GO}$
  by listing its components $\Con$, $\Ty$, $\Sub$, and so on, one per
  row. Each component has two parts denoted by $^\I$ and $^\C$. The
  $^\I$ part just reuses the corresponding components from $\I$, and
  thus the morphism $\blank^\I$ is defined as the obvious
  projection. We omit the equality components, as they come from UIP
  or are trivial. We also omit the components for terms and
  substitutions as their $^\C$ parts consist of uninformative equational
  reasoning.
  \begin{alignat*}{10}
    & \GG^\I:\Con^\I && \hspace{1em} && \GG^\C: \Sub^\I\,\GO\,\GG^\I\ra \ll\GG\rr_\A \\
    & A^\I:\Ty^\I\,\GG^\I && && A^\C:(\nu:\Sub^\I\,\GO\,\GG^\I)\ra\Tm^\I\,\GO\,(A^\I[\nu])\ra \ll A\rr_\A\,(\GG^\C\,\nu) \\
    & \sigma^\I:\Sub^\I\,\GG^\I\,\GD^\I && && \sigma^\C:\GD^\C\,(\sigma^\I\circ\nu)=\ll\sigma\rr_\A\,(\GG^\C\,\nu) \\
    & t^\I:\Tm^\I\,\GG^\I\,A^\I && && t^\C : A^\C\,\nu\,(t^\I[\nu])= \ll t\rr_\A\,(\GG^\C\,\nu) \\
    & (A[\sigma])^\I := A^\I[\sigma^\I]^\I && && (A[\sigma])^\C\,\nu\,t := A^\C\,(\sigma^\I\circ\nu)\,t \\
    & \cdot^\I := \cdot^\I && && \cdot^\C\,\nu := \tt \\
    & (\GG\rhd A)^\I := \GG^\I\rhd^\I A^\I && && (\GG\rhd A)^\C\,\nu := (\GG^\C\,(\pi_1\,\nu), A^\C\,(\pi_1\,\nu)\,(\pi_2\,\nu)) \\
    & \U^\I := \U^\I && && \U^\C\nu\,a := \Tm^\I\,\GO\,(\El^\I\,a) \\
    & (\El\,a)^\I := \El^\I\,a^\I && && (\El\,a)^\C\,\nu\,t := _{a^\C\,\nu\#}t \\
    & (\Pi\,a\,B)^\I := \Pi^\I\,a^\I\,B^\I && && (\Pi\,a\,B)^\C\,\nu\,t := \lambda\alpha.B^\C\,(\nu, _{a^\C\,\nu\#}\alpha)\,(t\oldapp {_{a^\C\,\nu\#}\alpha}) \\
    & (\Pim\,T\,B)^\I := \Pim^\I\,T\,B^\I && && (\Pim\,T\,B)^\C\,\nu\,t := \lambda\alpha.(B\,\alpha)^\C\,\nu\,(t\appm\alpha)
  \end{alignat*}
\end{definition}
\begin{example}\label{ex:constructors}
  Now, given a syntactic signature $\GO:\Con^\I$, we get the
  constructors as an $\GO$-algebra by
  $\omega:=(\ll\GO\rr_{\IC_\GO})^\C\,\id^\I :
  \ll\GO\rr_\A$. If $\GO$ is the syntactic signature for natural
  numbers, we get the constructors as in \Cref{eg:nat_con}.

  An $a : \Tm^\I\,\GO\,\U$ is a sort term for the syntactic
  signature $\GO$. If $\GO$ is the syntactic signature for
  natural numbers, $a$ can only be $N$ ($1$ as a de Bruijn index). If
  $\GO$ is the syntactic signature for $\Con$--$\Ty$
  (\Cref{ex:contexts}), $a$ can be $Con$, $Ty\oldapp{empty}$,
  $Ty\oldapp({ext}\oldapp {empty}\oldapp(U\oldapp{empty}))$, and so
  on. In any case, for such an $a$, we obtain
  $(\ll a\rr_{\IC_\GO})^\C\,\id^\I : \Tm^\I\,\GO\,(\El\,a) = \ll
  a\rr_\A\,\omega$. That is, the algebra interpretation of a sort term
  at the constructors is equal to terms of that sort.

  A $t : \Tm^\I\,\GO\,(\El\,a)$ is a term of a sort type $a$
  constructed using the constructors in $\GO$. For natural numbers,
  such a $t$ can only be $s$ applied iteratively to $z$. For such a
  $t$, we obtain
  $(\ll t\rr_{\IC_\GO})^\C\,\id^\I : (t = \ll
  t\rr_\A\,\omega)$. That is, a constructor term is equal to its
  algebra interpretation at the constructors. This is exactly the
  equation needed at the end of \Cref{eg:nat_con}.
\end{example}

\begin{definition}[Eliminator signature algebra $\IE_{\blank}$]
  Given an $\GO:\Con^\I$, we use the abbreviation
  $\omega := \ll\GO\rr_{\IC_\GO}\,\id^\I$ as in
  \Cref{ex:constructors}. Assuming an
  $\omega^D : (\ll\GO\rr_{\ADS})^\D\,\omega$, we define the
  signature algebra $\IE_{\omega^\D}$. It is equipped with a morphism
  $\blank^\I : \SignMor\,\IE_{\omega^D}\,\I$. We define
  $\IE_{\omega^D}$ by listing its components $\Con$, $\Ty$, $\Sub$,
  and so on, one per row. Each component has two parts denoted by
  $^\I$ and $^\E$. The $^\I$ part just reuses the corresponding
  components of $\I$, thus the morphism $\blank^\I$ is defined as the
  obvious projection. We omit the equality components, as they come
  from UIP or are trivial. We also omit the components for terms and
  substitutions as their $^\E$ parts are uninformative equational
  reasonings.
  \begin{alignat*}{10}
    & \GG^\I:\Con^\I && \hspace{1em} && \GG^\E:(\nu:\Sub^\I\,\GO\,\GG^\I)\ra \ll\GG\rr^\S\,(\ll\nu\rr^\A\,\omega)\,(\ll\nu\rr^\D\,\omega^D) \\
    & A^\I:\Ty^\I\,\GG^\I && && A^\E:(\nu:\Sub^\I\,\GO\,\GG^\I)(t:\Tm^\I\,\GO\,(A^\I[\nu]))\ra \\
    & && && \hspace{1em} \ll A\rr^\S\,(\GG^\E\,\nu)\,(\ll t\rr^\A\,\omega)\,(\ll t\rr^\D\,\omega^D) \\
    & \sigma^\I:\Sub^\I\,\GG^\I\,\GD^\I && && \sigma^\E:\GD^\E\,(\sigma^\I\circ\nu)=\ll\sigma\rr^\S\,(\GG^\E\,\nu) \\
    & t^\I:\Tm^\I\,\GG^\I\,A^\I && && t^\E : A^\E\,\nu\,(t^\I[\nu])= \ll t\rr^\S\,(\GG^\E\,\nu) \\
    & (A[\sigma])^\I := A^\I[\sigma^\I]^\I && && (A[\sigma])^\E\,\nu\,t := A^\E\,(\sigma^\I\circ\nu)\,t \\
    & \cdot^\I := \cdot^\I && && \cdot^\E\,\nu := \tt \\
    & (\GG\rhd A)^\I := \GG^\I\rhd^\I A^\I && && (\GG\rhd A)^\E\,\nu := (\GG^\E\,(\pi_1\,\nu), A^\E\,(\pi_1\,\nu)\,(\pi_2\,\nu)) \\
    & \U^\I := \U^\I && && \U^\E\nu\,a := \lambda\alpha . _{\ll\alpha\rr^\C\,\id\#}\big(\ll_{\ll\alpha\rr^\C\,\id\#}\alpha\rr^\D\,\omega^D\big) \\
    & (\El\,a)^\I := \El^\I\,a^\I && && (\El\,a)^\E\,\nu\,t := \big(\ll a\rr^\S\,(\GG^\E\,\nu)\,(\ll t\rr^\A\,\omega) \overset{\ll t\rr^\C\,\id}{=} \ll a\rr^\S\,(\GG^\E\,\nu)\,t \overset{a^\E\,\nu}{=} \ll t\rr^\D\,\omega^D\big) \\
    & (\Pi\,a\,B)^\I := \Pi^\I\,a^\I\,B^\I && && (\Pi\,a\,B)^\E\,\nu\,t := \\
    & && && \hspace{1em} \lambda\alpha.{_{\ll\alpha\rr^\C\,\id\#}}\big(B^\E\,(\nu,_{\ll a\rr^\C\,\id,\ll\nu\rr^\C\,\id\#}\alpha)\,(t\oldapp {_{\ll a\rr^\C\,\id,\ll\nu\rr^\C\,\id\#}u})\big) \\
    & (\Pim\,T\,B)^\I := \Pim^\I\,T\,B^\I && && (\Pim\,T\,B)^\E\,\nu\,t := \lambda\alpha.(B\,\alpha)^\E\,\nu\,(t\appm\alpha)
  \end{alignat*}
\end{definition}
\begin{example}
  Given the assumptions $\GO$, $\omega^D$ of $\IE$, we obtain the
  eliminator by
  $\ll\GO\rr_{\IE_{\omega^\D}}\,\id^\I :
  \ll\GO\rr^\S\,\omega\,\omega^D$. The eliminator is a section of
  the displayed algebra $\omega^D$, that is, a dependent function
  together with equalities witnessing that all the operations are
  preserved. If $\GO$ is the syntactic signature for natural
  numbers, we get the eliminator of \Cref{eg:nat_con}.

  For a sort term $a:\Tm^\I\,\GO\,\U$, the interpretation
  $(\ll a\rr_{\IE_{\omega^D}})^\E\,\id$ says that
  $(\lambda\alpha.\ll\alpha\rr^\D\,\omega^D) = \ll
  a\rr^\S\,(\ll\GO\rr^\E\,\id)$, that is, the function for the sort
  $a$ in the eliminator section is the displayed algebra
  interpretation at $\omega^D$ (motives and methods). For natural
  numbers, this is the same as
  $\big(\lambda n.\ll n\rr^D\,(N^D,z^D,s^D)\big) = \big(\lambda
  n.\mathsf{elimNat}\,(N^D,z^D,s^D)\,n)\big)$.

  The interpretation of a constructor term
  $t:\Tm^\I\,\GO\,(\El\,a)$ is uninteresting as it provides an
  equality between two different equality proofs of the computation
  ($\beta$) rule for $t$.
\end{example}

\begin{theorem}\label{thm:ToSToIITs}
  If a model of type theory supports the theory of IIT signatures,
  then it supports all IITs.
\end{theorem}
\begin{proof}
  For a signature $({sig},{sigc})$, we define constructors as
  \[
    \con_{sig}:= (\ll{sig}\,\I\rr_{\IC_{{sig}\,\I}})^\C\,\id^\I : ({sig}\,\ADS)^\A
  \]
  This typechecks as
  $\ll{sig}\,\I\rr_\A = \ll\blank\rr_\A\,({sig}\,\I)
  \overset{{sigc}}{=} {{sig}\,\A} = ({sig}\,\ADS)^\A$. We define the
  eliminator by
  and an
  \[
    \elim_{sig}\,\gamma^D := (\ll{sig}\,\I\rr_{\IE_{\gamma^D}})^\E\,\id^\I  : ({sig}\,\ADS)^\S\,\con_{sig}\,\gamma^D.
  \]
  This typechecks firstly because the type of $\gamma^D$ matches the
  type of the parameter of $\IE$:
  \[
    ({sig}\,\ADS)^\D\,\con_{sig} \overset{{sigc}}{=}
    (\ll\blank\rr_{\ADS}\,({sig}\,\I))^\D\,\con_{sig} =
    (\ll{sig}\,\I\rr_{\ADS})^\D\,\con_{sig},
  \]
  and the result also has the correct type:
  \[
    \ll{sig}\,\I\rr^\S\,\con_{sig}\,\gamma^D = (\ll\blank\rr_{\ADS}\,({sig}\,\I))^\S\,\con_{sig}\,\gamma^D \overset{{sigc}}{=} ({sig}\,\ADS)^\S\,\con_{sig}\,\gamma^D.
  \]
\end{proof}

\begin{remark}\label{remark:sigc}
  In the above proof, we crucially relied on the ${sigc}$ property to
  define the constructors (and the eliminator). This is why the simple
  Church encoding of signatures is not sufficient.
\end{remark}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Constructing the Theory of IIT Signatures}
\label{sec:ambroise}

In this section we show that any model of ETT which supports indexed W-types
also supports the theory of signatures, and as a consequence of
\Cref{thm:ToSToIITs}, all IITs. For this, we work in the internal language of a
model of ETT supporting indexed W-types \cite{indexedcont}. Indexed W-types
correspond to the usual notion of (possibly mutual) indexed inductive types. We
use Agda-style notation to define such inductive families: we list the sorts and
constructors and use pattern matching when eliminating from them. For an
encoding of mutual inductive families as indexed W-types, see
e.g.\ \cite{mutual}.

\input{universaliit}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Further Work}
\label{sec:conclusions}

The current work only concerns finitary IITs. An extension would be to
also allow infinitely branching inductive types such as W-types. This
would first require giving semantics for infinitary IITs and adapting
the term model construction. These would be straightforward following
\cite{large_inf_qiit}. However, it seems to be more difficult to
construct the syntax of infinitary IIT signatures without using
quotients. The reason is that such syntax would not be strictly
restricted to neutral terms: the term model construction for
infinitary IITs requires $\lambda$-abstraction and $\beta\eta$-rules
for infinitary $\Pi$ types. A definition of normal preterms and typing
judgments on them may still be possible, but it appears to be much
more complicated than before (the current authors have attempted this
without conclusive success).

As mentioned in Section \ref{sec:right_uniqueness}, it also remains an open
problem whether IITs are reducible to inductive types in a UIP-free setting. To
show this, we would need to construct the syntax of signatures without UIP, and
also reproduce the semantics and term model construction for IITs without UIP.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\bibliography{b}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage

\appendix

\end{document}
