
\documentclass[a4paper,UKenglish,cleveref, autoref]{lipics-v2019}
%This is a template for producing LIPIcs articles.
%See lipics-manual.pdf for further information.
%for A4 paper format use option "a4paper", for US-letter use option "letterpaper"
%for british hyphenation rules use option "UKenglish", for american hyphenation rules use option "USenglish"
%for section-numbered lemmas etc., use "numberwithinsect"
%for enabling cleveref support, use "cleveref"
%for enabling cleveref support, use "autoref"
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{hyperref}
\usepackage{todonotes}
\presetkeys{todonotes}{inline}{}
\usepackage{csquotes} %for \llbracket and \rrbracket
\usepackage{stmaryrd}
% \usepackage{pdflscape} % if we want \begin{landscape} ... \end{landscape}

%\graphicspath{{./graphics/}}%helpful if your graphic files are in another directory

\bibliographystyle{plainurl}% the mandatory bibstyle

\title{For Finitary Induction-Induction, \\ Induction is Enough} %TODO Please add

\titlerunning{For Finitary Induction-Induction, Induction is Enough}%optional, please use if title is longer than one line

\author{Ambrus Kaposi}{E{\"o}tv{\"o}s Lor{\'a}nd University, Budapest, Hungary}{akaposi@inf.elte.hu}{https://orcid.org/0000-0001-9897-8936}{this author was supported by Thematic Excellence Programme, Industry and Digitization Subprogramme (NRDI Office, 2019) and by the European Union, co-financed by the European Social Fund (EFOP-3.6.2-16-2017-00013, Thematic Fundamental Research Collaborations Grounding Innovation in Informatics and Infocommunication).}%TODO mandatory, please use full name; only 1 author per \author macro; first two parameters are mandatory, other parameters can be empty. Please provide at least the name of the affiliation and the country. The full address is optional
\author{Andr{\'a}s Kov{\'a}cs}{E{\"o}tv{\"o}s Lor{\'a}nd University, Budapest, Hungary}{kovacsandras@inf.elte.hu}{https://orcid.org/0000-0002-6375-9781}{this author was supported by the European Union, co-financed by the European Social Fund (EFOP-3.6.3-VEKOP-16-2017-00002).}
\author{Ambroise Lafont}{IMT Atlantique, Inria, LS2N CNRS, Nantes, France}{ambroise.lafont@inria.fr}{https://orcid.org/0000-0002-9299-641X}{}

\authorrunning{A. Kaposi, A. Kov{\'a}cs and A. Lafont}%TODO mandatory. First: Use abbreviated first/middle names. Second (only in severe cases): Use first author plus 'et al.'

\Copyright{A. Kaposi, A. Kov{\'a}cs and A. Lafont}%TODO mandatory, please use full first names. LIPIcs license is "CC-BY";  http://creativecommons.org/licenses/by/3.0/

\ccsdesc[500]{Theory of computation~Logic~Type theory}%TODO mandatory: Please choose ACM 2012 classifications from https://dl.acm.org/ccs/ccs_flat.cfm

\keywords{type theory, inductive types, inductive-inductive types}%TODO mandatory; please add comma-separated list of keywords

\category{}%optional, e.g. invited paper

\relatedversion{}%optional, e.g. full version hosted on arXiv, HAL, or other respository/website
%\relatedversion{A full version of the paper is available at \url{...}.}

\supplement{}%optional, e.g. related research data, source code, ... hosted on a repository like zenodo, figshare, GitHub, ...

%\funding{(Optional) general funding statement \dots}%optional, to capture a funding statement, which applies to all authors. Please enter author specific funding statements as fifth argument of the \author macro.

\acknowledgements{The authors would like to thank Thorsten Altenkirch, Simon Boulier, Fredrik Nordvall-Forsberg and Jakob von Raumer for discussions on the topics of this paper.}%optional

%\nolinenumbers %uncomment to disable line numbering

%\hideLIPIcs  %uncomment to remove references to LIPIcs series (logo, DOI, ...), e.g. when preparing a pre-final version to be uploaded to arXiv or another public repository

%Editor-only macros:: begin (do not touch as author)%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\EventEditors{John Q. Open and Joan R. Access}
\EventNoEds{2}
\EventLongTitle{42nd Conference on Very Important Topics (CVIT 2016)}
\EventShortTitle{CVIT 2016}
\EventAcronym{CVIT}
\EventYear{2016}
\EventDate{December 24--27, 2016}
\EventLocation{Little Whinging, United Kingdom}
\EventLogo{}
\SeriesVolume{42}
\ArticleNo{23}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\input{abbrevs.tex}

\allowdisplaybreaks

\begin{document}
\maketitle

\begin{abstract}
  Inductive-inductive types (IITs) are a generalisation of inductive types in
  type theory. They allow the mutual definition of types with multiple sorts
  where later sorts can be indexed by previous ones. An example is the
  Chapman-style syntax of type theory with conversion relations for each sort
  where e.g.\ the sort of types is indexed by contexts. It follows from previous
  work by Altenkirch, Kaposi, and Kov{\'a}cs, that all finitary IITs can be constructed from a quotient
  inductive-inductive type (QIIT), namely the theory of IIT signatures. This is
  a small domain-specific type theory where a context is a signature for an
  IIT. In this paper we construct the theory of IIT signatures using only inductive types,
  thereby showing a reduction of all finitary IITs to inductive types.  We rely
  on function extensionality and uniqueness of identity proofs. We formalised
  the construction of the theory of IIT signatures in Agda. TODO: rewrite
\end{abstract}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Introduction}
\label{sec:intro}

Many mutual inductive types can be reduced to indexed inductive types, where the
index disambiguates different sorts. For example, consider the mutual inductive datatype
with two sorts
$\mathsf{isEven}$ and $\mathsf{isOdd}$, defined by the following
constructors.
\begin{alignat*}{5}
  & \mathsf{isEven} && : \N\ra\Set \\
  & \mathsf{isOdd} && : \N\ra \Set \\
  & \mathsf{zeroEven} && : \mathsf{isEven}\,\mathsf{zero} \\
  & \mathsf{sucEven} && : (n:\N)\ra\mathsf{isOdd}\,n\ra\mathsf{isEven}\,(\mathsf{suc}\,n) \\
  & \mathsf{sucOdd} && : (n:\N)\ra\mathsf{isEven}\,n\ra\mathsf{isOdd}\,(\mathsf{suc}\,n)
\end{alignat*}
This can be reduced to the following single inductive family where
$\mathsf{isEven?}\,\mathsf{true}$ represents $\mathsf{isEven}$ and
$\mathsf{isEven?}\,\mathsf{false}$ represent $\mathsf{isOdd}$.
\begin{alignat*}{5}
  & \mathsf{isEven?} && : \mathsf{Bool}\ra\N\ra\Set \\
  & \mathsf{zeroEven} && : \mathsf{isEven?}\,\mathsf{true}\,\mathsf{zero} \\
  & \mathsf{sucEven} && : (n:\N)\ra\mathsf{isEven?}\,\mathsf{false}\,n\ra\mathsf{isEven?}\,\mathsf{true}\,(\mathsf{suc}\,n) \\
  & \mathsf{sucOdd} && : (n:\N)\ra\mathsf{isEven?}\,\mathsf{true}\,n\ra\mathsf{isEven?}\,\mathsf{false}\,(\mathsf{suc}\,n)
\end{alignat*}

Inductive-inductive types (IITs \cite{forsberg-phd}) allow the mutual
definition of a type and a family of types over the first one. IITs
were originally introduced to represent the well-typed syntax of type
theory itself, and the main example is still the Chapman-style
\cite{chapman09eatitself} syntax for a type theory. A minimsed version
is the IIT of contexts and types given by the following constructors.
\begin{alignat*}{5}
  & \Con && : \Set \\
  & \Ty && : \Con\ra\Set \\
  & \mathsf{empty} && : \Con \\
  & \mathsf{ext} && : (\Gamma:\Con)\ra\Ty\,\Gamma\ra\Con \\
  & \mathsf{U} && : (\Gamma:\Con)\ra\Ty\,\Gamma \\
  & \mathsf{El} && : (\Gamma:\Con)\ra\Ty\,(\mathsf{ext}\,\Gamma\,(\mathsf{U}\,\Gamma))
%  & \mathsf{Pi} && : (\Gamma:\Con)(A:\Ty\,\Gamma)\ra\Ty\,(\mathsf{ext}\,\Gamma\,A)\ra\,\Ty\,\Gamma
\end{alignat*}
This type has two sorts, $\Con$ and $\Ty$. The $\mathsf{ext}$ constructor of
$\Con$ refers to $\Ty$ and the $\Ty$-constructor $\mathsf{U}$ refers to $\Con$,
hence the two sorts have to be defined simultaneously. Moreover, $\Ty$ is
indexed over $\Con$. This precludes a reduction analogous to the reduction of
$\mathsf{isEven}$--$\mathsf{isOdd}$, as we would get a type indexed over
itself. Another unique feature of IITs (which also shows up in higher inductive
types \cite{HoTTbook}) is that later constructors can refer to previous
constructors: in our case, $\mathsf{El}$ mentions
$\mathsf{ext}$.
% \[
%   \mathsf{Con?} : (b:\mathsf{Bool})\ra\mathsf{if}\,b\,\mathsf{then}\,\Set\,\mathsf{else}\,(\mathsf{Con?}\,\mathsf{false}\ra\Set),
% \]

The elimination principle for the above IIT has the following two
motives (one for each sort) and four methods (one for each
constructor).
\begin{alignat*}{5}
  & Con^D && : \Con\ra\Set \\
  & Ty^D && : Con^D\,\Gamma\ra\Ty\,\Gamma\ra\Set \\
  & {empty}^D && : Con^D\,\mathsf{empty} \\
  & {ext}^D && : (\Gamma^D:Con^D\,\Gamma)\ra Ty^D\,\Gamma^D\,A\ra Con^D\,(\mathsf{ext}\,\Gamma\,A) \\
  & U^D && : (\Gamma^D:Con^D\,\Gamma)\ra Ty^D\,\Gamma^D\,(\mathsf{U}\,\Gamma) \\
  & El^D && : (\Gamma^D:Con^D\,\Gamma)\ra\,Ty^D\,({ext}^D\,\Gamma^D\,(U^D\,\Gamma^D))\,(\mathsf{El}\,\Gamma)
%  & Pi^D && : (\Gamma^D:Con^D\,\Gamma)(A^D:\Ty^D\,\Gamma^D\,A)\ra \Ty^D\,(\mathsf{ext}^D\,\Gamma^D\,A^D)\ra\,\Ty^D\,\Gamma^D\,(\mathsf{Pi}\,\Gamma\,A\,B)
\end{alignat*}
Above we used implicit quantifications for $\Gamma:\Con$ and
$A:\Ty\,\Gamma$ to ease readability, e.g.\ $Ty^D$ has an implicit
parameter $\Gamma$ before its explicit parameter of type
$Con^D\,\Gamma$.

Given the above motives and methods the elimination principle provides
two functions
\begin{alignat*}{5}
  & \mathsf{elimCon} && : (\Gamma:\Con)\ra Con^D\,\Gamma \\
  & \mathsf{elimTy} && : (A:\Ty\,\Gamma)\ra Ty^D\,(\mathsf{elimCon}\,\Gamma)\,A
\end{alignat*}
with the following computation rules.
\begin{alignat*}{5}
  & \mathsf{elimCon}\,\mathsf{empty} && = {empty}^D \\
  & \mathsf{elimCon}\,(\mathsf{ext}\,\Gamma\,A) && = {ext}^D\,(\mathsf{elimCon}\,\Gamma)\,(\mathsf{elimTy}\,A) \\
  & \mathsf{elimTy}\,(\mathsf{U}\,\Gamma) && = U^D\,(\mathsf{elimCon}\,\Gamma) \\
  & \mathsf{elimTy}\,(\mathsf{El}\,\Gamma) && = El^D\,(\mathsf{elimCon}\,\Gamma)
\end{alignat*}
The functions $\mathsf{elimCon}$ and $\mathsf{elimTy}$ are an example
of a \emph{recursive-recursive} definition (using nomenclature from
\cite{forsberg-phd}). This means two mutually defined functions where
the type of the second function depends on the first function. The
proof assistant Agda \cite{norell07thesis} allows defining such
functions (even from non-IITs) and it is currently the only proof
assistant supporting IITs\footnote{An experimental version of Coq with
  IITs is also available on GitHub.}.

Reducing IITs to inductive types (more precisely, to indexed W-types)
is an open problem. Forsberg \cite{forsberg-phd} showed a reduction in
extensional type theory however this only provides a simpler,
non-recursive-recursive elimination principle. Hugunin \cite{jasper}
reduced several IITs to inductive types, working inside a cubical type
theory, but he also only constructed the simple eliminator. To
illustrate the difference, we list the motives and methods and the
simple elimination principle for the $\Con$--$\Ty$ example. Again, we
use implicit quantifications.
\begin{alignat*}{5}
  & Con^S && : \Con\ra\Set \\
  & Ty^S && : \Ty\,\Gamma\ra\Set \\
  & {empty}^S && : Con^S\,\mathsf{empty} \\
  & {ext}^S && : Con^S\,\Gamma\ra Ty^S\,\,A\ra Con^S\,(\mathsf{ext}\,\Gamma\,A) \\
  & U^S && : Con^S\,\Gamma\ra Ty^S\,(\mathsf{U}\,\Gamma) \\
  & El^S && : Con^S\,\Gamma\ra\,Ty^S\,(\mathsf{El}\,\Gamma) \\
  & \mathsf{selimCon} && : (\Gamma:\Con)\ra Con^S\,\Gamma \\
  & \mathsf{selimTy} && : (A:\Ty\,\Gamma)\ra Ty^S\,A
\end{alignat*}
This simple elimination principle is too weak e.g.\ to define the
standard (metacircular) interpretation of our small syntax
\cite{ttintt}. Using pattern matching notation, this interpretation is
the following:
\begin{alignat*}{5}
  & \ll\blank\rr && : \Con\ra\Set_1 \\
  & \ll\blank\rr && : \ll\Gamma\rr\ra\Set_1 \\
  & \ll\mathsf{empty}\rr && := \top \\
  & \ll\mathsf{ext}\,\Gamma\,A\rr && := (\gamma:\ll\Gamma\rr)\times\ll A\rr\,\gamma \\
  & \ll\mathsf{U}\,\Gamma\rr\,\gamma && := \Set \\
  & \ll\mathsf{El}\,\Gamma\rr\,(\gamma,X) && := X
\end{alignat*}
The reason that we need the general elimination principle is that
$\ll\blank\rr$ for types refers to $\ll\blank\rr$ for contexts, hence
this function is recursive-recursive.

Kaposi, Kov{\'a}cs, and Altenkirch
\cite{Kaposi:2019:CQI:3302515.3290315} introduced a small type theory
called the theory of signatures to describe quotient
inductive-inductive types (QIIT). QIITs are generalisations of IITs
where equality constructors are also allowed. A QIIT signature is a
context in the theory of QIIT signatures, for example natural numbers
are specified by the context $(Nat:\U,zero:Nat,suc:Nat\ra Nat)$ of
length three ($Nat$, $zero$ and $suc$ are variable names). The theory
of QIIT signatures is itself a QIIT. In ibid., it is proved that if a
model of extensional type theory supports the theory of QIIT
signatures, then it supports all QIITs.

By omitting the equality type former from the theory of QIIT
signatures, we obtain a theory of IIT signatures and the construction
is still valid. It follows that if a model of extensional type theory
supports the theory of IIT signatures, it supports all IITs.

In this paper we show that any model of extensional type theory with
indexed W-types supports the theory of IIT signatures, hence all
IITs. The difficulty is that the theory of IIT signatures is a QIIT,
it is both inductive-inductive and has equality constructors. However
it can be seen as the well-typed syntax of a small type theory without
any computation rules. Hence we can represent the syntax of normal
forms without quotienting. We construct this well-typed normal syntax
using preterms and typing relations from indexed W-types. Finally, we
prove the elimination principle in the style of the initiality proof
of Streicher \cite{streichersemantics}.

Just as ibid., we only consider finitary IITs, that is, constructors
can only have a finite number of recursive arguments. An example
constructor for $\Con$--$\Ty$ which is not allowed is the following:
\[
  \Pi_\infty : (\Gamma : \Con) \rightarrow (\mathbb{N} \rightarrow \Ty\,\Gamma) \rightarrow \Ty\,\Gamma
\]

TODO: list of contributions here. Notion of signature free from encoding.

The contents of this paper were presented at the TYPES 2019 conference
in Oslo \cite{types}.

\subsection{Structure of the Paper}

We first define a theory of IIT signatures in which every context is a signature
(Section \ref{sec:theory_of_signatures}). We present this as an algebraic
\cite{ttintt} theory, specifically as a quotient inductive-inductive type
(QIIT). In Section \ref{sec:ambroise} we show that this QIIT can be constructed
using inductive types, UIP and function extensionality. In Section
\ref{sec:constructingiits} we describe the construction of IITs from the syntax
of IIT signatures.

\subsection{Related Work}

The current work builds heavily on the work of Kaposi et al.\
\cite{Kaposi:2019:CQI:3302515.3290315} on finitary quotient
inductive-inductive types (QIITs); we reuse both QIIT syntax and
semantics by restricting to IITs, and we reuse the term model
construction of QIITs as well. We also make use of the extesion to
infinitary QIITs \cite{large_inf_qiit} to derive the specification of
the elimination principle for the theory of IIT signatures. TODO: also
for specifying signatures.

IITs (however not by this name) were first used to describe the
well-typed syntax of type theory \cite{nisse,chapman09eatitself}. Agda
supported these general inductive definitions even before they were
named IITs and given semantics by Nordvall Forsberg and Setzer
\cite{nordvallforsbergSetzer2010inductiveinductive}. Nordvall
Forsberg's thesis \cite{forsberg-phd} contains a specification similar
in style to Dybjer and Setzer's codes for inductive-recursive types
\cite{Dybjer99afinite}. He also develops a categorical semantics based
on dialgebras and provides a reduction of IITs to indexed inductive
types, however only constructs the simple elimination principle as
opposed to the general one. Altenkirch et al.\ \cite{gabe} define
signatures for QIITs (thus IITs as well) and their categorical
semantics, however without proving existence of initial
algebras. Their notion of signature, just as Nordvall Forsberg's
involves more encoding overhead than ours.

Cartmell \cite{gat} introduced generalised algebraic theories using a
type-theoretic syntax. Removing equations from his signatures, we
obtain finitary IIT signatures similar to ours. He does not consider
constructing initial algebras using simpler classes of inductive
types.

Hugunin \cite{jasper} constructs several IITs in cubical Agda from
inductive types. In this setting, the lack of UIP makes constructions
significantly more involved, and essentially involves
coinductive-coinductive well-formedness predicates defined as homotopy
limits. Hugunin does not consider a generic syntax of IITs and only
works on specific examples (although the examples vary greatly). He
also only constructs the simple elimination principle.

Streicher \cite{streichersemantics} presents an interpretation of the well-formed
presyntax of a type theory into a categorical model, which is an important
ingredient in constructing an initial model, although he does not present
details on the construction of the term model or its initiality proof. Our
initiality proof can be seen as an indexed variant of his construction
(see Subsection \ref{sec:streicher} for a comparison).

Voevodsky was interested in constructing initial models of type
theories from presyntaxes. Inspired by this, Brunerie et al.\ \cite{brunerie}
formalised Streicher's proof in Agda for a type theory with $\Pi$,
$\Sigma$, $\mathbb{N}$, identity types and an infinite hierarchy of
universes. He used UIP, function extensionality and quotient types in
his formalisation. In this paper we construct a type theory without
computation rules, hence we avoid using quotients.

Intrinsic (well-typed) syntax for type theories were constructed using
IITs \cite{chapman09eatitself}, inductive-recursive types
\cite{nisse,Altenkirch:2014:CO:2631172.2631176} and QIITs
\cite{ttintt}. In this paper we avoid using such general classes of
inductive types as our goal is to reduce IITs to indexed inductive
types.

Reducing general classes of inductive types to simpler classes has a
long tradition in type theory. Indexed W-types were reduced to W-types
\cite{indexedcont} (using the essentially Streicher's idea of preterms
and a typing predicate), small inductive-recursive types to indexed
W-types \cite{malatasta13smallir}, mutual inductive types to indexed
W-types \cite{mutual}, W-types to natural numbers and quotients
\cite{Ahrens2019}. (Q)IITs can be reduced to quotient inductive types
using the reduction of generalised algebraic theories to essentially
algebraic theories \cite{gat}. Using the same reduction as mutual
inductive types to indexed inductive types, (Q)IITs with more than two
sorts can be reduced to (Q)IITs with only two sorts \cite{szumiemail}.

Our reduction of IITs to indexed inductive types goes through two
steps: first we construct a concrete QIIT using inductive types, then
we construct all IITs from this particular QIIT. A more direct
approach is proposed by \cite{erasure}: here the initial algebra would
be constructed directly for any IIT signature without going through an
intermediate step.

\subsection{Notation and Formalisation}

\begin{definition}[Model of extensional type theory (ETT)]
  By a model of ETT we mean a category with families (CwF)
  \cite{Dybjer96internaltype,Hofmann97syntaxand} with an infinite
  predicative hierarchy of universes closed under the following type
  formers: $\Pi$, $\Sigma$, $\bot$, $\top$, $\Bool$, indexed W-types
  \cite{indexedcont} and an identity type with uniqueness of identity
  proofs and equality reflection. TODO: remove indexed W-types, bot
  and bool.
\end{definition}

We will use Agda-like type theoretic syntax to work in the internal
language of models of ETT:
\begin{itemize}
\item Universes are written $\Set_i$. We usually omit level indices in this paper.
\item $\Pi$ types are notated as $(x : A)\ra B$, or as $A \ra B$ when
  non-dependent. We sometimes omit function arguments, by implicitly
  generalising over variables.
\item $\Sigma$-types, notated either as $(x : A)\times B$, or as
  $\sum\limits_{x} B$ when we want to leave the type of the first
  projection implicit. Projections are either named or given by
  $\proj_1$ and $\proj_2$. We use $A \times B$ for non-dependent
  pairs.
\item We will define indexed W-types \cite{indexedcont} by listing
  their constructors and using pattern matching to eliminate from
  them.
\item The equality (identity) type is written $t = u$, it has a
  constructor $\refl : t = t$, and equality reflection, hence we use
  the same $=$ sign for definitional equality. We occasionally
  indicate by $e_1,\dots,e_n \#t$ that $t$ is well-typed thanks to the
  equalities $e_1$,\dots,$e_n$. We also have uniqueness of identity
  proofs (UIP), expressing $(e : t = t)\ra e = \refl$. Note that
  function extensionality, expressing
  $((x : A) \ra f\,x = g\,x) \ra f = g$ is derivable.
\end{itemize}

The contents of Sections \ref{sec:theory_of_signatures} and
\ref{sec:ambroise} were formalised in Agda, the formalisation is
available at \url{https://github.com/amblafont/UniversalII}. Agda's
pattern matching mechanism implies uniqueness of identity proofs, we
assumed function extensionality as an axiom and used rewrite rules
\cite{cockxsprinkles} to obtain limited equality reflection.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{The Theory of IIT Signatures}
\label{sec:theory_of_signatures}

TODO: rewrite.

In this section we show how to describe signatures for IITs using a
QIIT, the theory of IIT signatures. We will say what it means for a
model of ETT to support the theory of IIT signatures. First we need to
say what a \emph{theory of IIT signature algebra} is and what
morphisms between such algebras are. Then supporting the theory of IIT
signatures means that there exists an algebra with a unique morphism
to every other algebra.

This description is analogous to saying that a model of ETT supports
natural numbers as follows: Using the internal language of the model,
a natural number algebra is given by a $\mathsf{Nat}:\Set$,
$\mathsf{zero}:\mathsf{Nat}$ and
$\mathsf{suc}:\mathsf{Nat}\ra \mathsf{Nat}$, while a morphism between
algebras $M$ and $N$ is given by a function
$f:\mathsf{Nat}^M\ra\mathsf{Nat}^N$ such that
$f\,\mathsf{zero}^M=\mathsf{zero}^N$ and
$f\,(\mathsf{suc}^M\,m)=\mathsf{suc}^N\,(f\,m)$. Natural numbers
themselves are given by an algebra equipped with a unique morphism
into any other algebra (the recursor).

We will call \emph{theory of IIT signature algebras} simply
\emph{signature algebras}. A signature algebra can be seen as a model
of a small type theory which consists of (1) a substitution calculus
(CwF \cite{Dybjer96internaltype}) equipped with (2) a universe, (3) a
function space where the domain is small and (3) another function
space with external domain. We explain the usage of these type
formers through examples after the definitions.

\begin{definition}[Signature algebra, $\SignAlg$]\label{def:algebra}
  In a model of ETT, a signature algebra is an iterated $\Sigma$ type
  consisting of the following components: four (families of) sets, 17
  operations and 18 equalities.
\begin{alignat*}{5}
  & \rlap{(1) Substitution calculus} \\
  & \Con && : \Set \\
  & \Ty  && : \Con\ra\Set \\
  & \Sub  && : \Con\ra\Con\ra\Set \\
  & \Tm  && : (\Gamma:\Con)\ra\Ty\,\Gamma\ra\Set \\
  & \id && : \Sub\,\Gamma\,\Gamma \\
  & \blank\circ\blank && : \Sub\,\Theta\,\Delta\ra\Sub\,\Gamma\,\Theta\ra\Sub\,\Gamma\,\Delta \\
  & \ass && : (\sigma \circ \delta) \circ \nu = \sigma \circ (\delta \circ \nu) \\
  & \idl && : \id\circ\sigma = \sigma \\
  & \idr && : \sigma\circ\id = \sigma \\
  & \blank[\blank] && : \Ty\,\Delta\ra\Sub\,\Gamma\,\Delta\ra\Ty\,\Gamma \\
  & \blank[\blank] && : \Tm\,\Delta\,A\ra(\sigma:\Sub\,\Gamma\,\Delta)\ra\Tm\,\Gamma\,(A[\sigma]) \\
  & [\id] && : A[\id] = A \\
  & [\circ] && : A[\sigma \circ \delta] = A[\sigma][\delta] \\
  & [\id] && : t[\id] = t \\
  & [\circ] && : t[\sigma \circ \delta] = t[\sigma][\delta] \\
  & \boldsymbol{\cdot} && : \Con \\
  & \epsilon && : \Sub\,\Gamma\,\boldsymbol{\cdot} \\
  & {\boldsymbol{\cdot}\eta} && : (\sigma : \Sub\,\Gamma\,\boldsymbol{\cdot}) \ra \sigma = \epsilon \\
  & \blank\ext\blank && : (\Gamma:\Con)\ra\Ty\,\Gamma\ra\Con \\
  & \blank,\blank && : (\sigma:\Sub\,\Gamma\,\Delta)\ra\Tm\,\Gamma\,(A[\sigma])\ra\Sub\,\Gamma\,(\Delta\ext A) \\
  & \pi_1 && : \Sub\,\Gamma\,(\Delta\ext A)\ra \Sub\,\Gamma\,\Delta \\
  & \pi_2 && : (\sigma : \Sub\,\Gamma\,(\Delta\ext A))\ra \Tm\,\Gamma\,(A[\pi_1 \sigma]) \\
  & {\pi_1\beta} && : \pi_1(\sigma, t) = \sigma \\
  & {\pi_2\beta} && : \pi_2(\sigma, t) = t \\
  & {\pi\eta} && : (\pi_1\,\sigma, \pi_2\,\sigma) = \sigma \\
  & {,\circ} && : (\sigma, t)\circ\delta = (\sigma\circ\delta, t[\delta]) \\
  & \rlap{(2) Universe} \\
  & \U && : \Ty\,\Gamma \\
  & \El && : \Tm\,\Gamma\,\U\ra\Ty\,\Gamma \\
  & {\U[]} && : \U[\sigma] = \U \\
  & {\El[]} && : (\El\,a)[\sigma] = \El\,(a[\sigma]) \\
  & \rlap{(3) Inductive parameters} \\
  & \Pi && : (a:\Tm\,\Gamma\,\U)\ra\Ty\,(\Gamma\ext\El\,a)\ra\Ty\,\Gamma \\
  & \blank\oldapp\blank && : \Tm\,\Gamma\,(\Pi\,a\,B)\ra (u : \Tm\,\Gamma\,(\El\,a))
  \ra \Tm\,\Gamma\,(\El\,(B[\id,\,u])) \\
  & {\Pi[]} && : (\Pi\,a\,B)[\sigma] = \Pi\,(a[\sigma])\,(B[\sigma\circ\p,\q]) \\
  & {\oldapp[]} && : (t\oldapp\alpha)[\sigma] = (t[\sigma])\mathop{\oldapp}(\alpha[\sigma]) \\
  & \rlap{(4) External parameters} \\
  & \Pim && : (T:\Set)\ra(T\ra\Ty\,\Gamma)\ra\Ty\,\Gamma \\
  & \blank\appm \blank && : \Tm\,\Gamma\,(\Pim\,T\,B)\ra(\alpha:T) \ra\Tm\,\Gamma\,(B\,\alpha) \\
  & {\Pim[]} && : (\Pim\,T\,B)[\sigma] = \Pim\,T\,(\lambda \alpha.(B\,\alpha)[\sigma]) \\
  & {\appm[]} && : (t\appm\alpha)[\sigma] = (t[\sigma])\mathop{\appm}\alpha
\end{alignat*}
Given an $M:\SignAlg$, we denote its components as $\Con^M$, $\Ty^M$,
$\Sub^M$, $\Tm^M$, $\id^M$, and so on.
\end{definition}

\begin{definition}[Abbreviations]\label{def:abbrevs}
  For any signature algebra, we use
  $\wk : \Sub\,(\Gamma\ext A)\,\Gamma$ to mean $\pi_1\,\id$. We
  recover de Bruijn indices by setting $0:= \pi_2 \,\id$ and
  $1+n := n[\wk]$. $\Pi\,a\,(B[\wk])$ is abbreviated by $a\Ra B$,
  $\Pim\,T\,(\lambda\_.B)$ by $T\Ram B$.
\end{definition}

\begin{definition}[IIT signature]
  An IIT signature is a context in an arbitrary signature algebra,
  that is, a function $(M:\SignAlg)\ra\Con^M$.
\end{definition}
Note that the notion of IIT signature is relative to a model of ETT:
it is expressed as a term (of a function type) in the model. This is
necessary because of the function space $\Pim$ which has as domain an
arbitrary type in the model. We make use of $\Pim$ in signatures with
external parameters, like the type of the elements in lists.

\begin{example}[Example signatures]\label{ex:signatures}
  The signature for natural numbers is given by the function
  \[
    nat := \lambda M.(\boldsymbol{\cdot}^M\,\ext^M\,\U^M\,\ext^M\,\El^M\,0^M\,\ext^M\,1^M \Ra^M \El^M\,1^M).
  \]
  For readability we write the same signature without the $\lambda$
  and the superscripts below on the left and we also write an informal
  version with variable names on the right for comparison.
  \[
  \boldsymbol{\cdot}\,\ext\,\U\,\ext\,\El\,0\,\ext\,1 \Ra \El\,1 \hspace{5.9em}
  \boldsymbol{\cdot}\,\ext\,N:\U\,\ext\,z : \El\,N\,\ext\,s : N \Ra \El\,N
  \]
  This signature is given by a context of length three. We start with
  the empty context $\boldsymbol{\cdot}$, then we declare a sort by
  $\U$, then we declare an operator producing an element of $\El\,0$
  where $0$ is a de Bruijn index referring to the sort $\U$. Finally
  we declare an operator which takes as input an element of the sort
  $1$ and produces an element of the same sort. Note the assymetry of
  the function type $\Ra$: on the left there needs to be an element of
  $\U$, while on the right any type can appear (including another
  function type). This ensures strict positivity of the operators.

  Lists with elements of a given $T : \Set$ type are given by the
  following signature. Here we use the function space with external
  domain $\Ram$ to include a $T$ in the signature. Again, we omit the
  $\lambda$ and the superscripts for readability.
  \begin{alignat*}{10}
    & \boldsymbol{\cdot}\,\ext\,\U\,\ext\,\El\,0\,\ext\,T\Ram 1\Ra \El\,1 \hspace{3.56em} \boldsymbol{\cdot}\,\ext\,L:\U\,\ext\,nil : \El\,L\,\ext\,cons : T\Ram L\Ra \El\,L
  \end{alignat*}
 
  The $\Con$--$\Ty$ example from \Cref{sec:intro} is specified as
  follows.
  \begin{alignat*}{5}
    & \boldsymbol{\cdot} \,\ext                                                 && \boldsymbol{\cdot} \,\ext                                                                \\
    & \U\,\ext                                                                  && Con && : \U\,\ext                                                                        \\
    & 0\Ra\U\,\ext                                                              && Ty && : Con\Ra\U\,\ext                                                                   \\
    & \El\,1\,\ext                                                              && empty && : \El\,Con\,\ext                                                                \\
    & \Pi\,2\,(2\oldapp 0 \Ra \El\,3)\ext                                       && ext && : \Pi\,(\Gamma : Con)\,(Ty\oldapp\Gamma \Ra \El\,Con)\ext                         \\
    & \Pi\,3\,(\El\,(3\oldapp 0))\,\ext                                         && U && : \Pi\,(\Gamma:Con)\,(\El\,(Ty\oldapp\Gamma))\,\ext                                 \\
    & \Pi\,4\,(\El\,(4\oldapp(2\oldapp 0\oldapp (1\oldapp 0)))) \hspace{4.79em} && El && : \Pi\,(\Gamma : Con)\,(\El\,(Ty\oldapp(ext\oldapp\Gamma\oldapp (U\oldapp\Gamma))))
  \end{alignat*}
\end{example}

Given a model of ETT and an IIT signature in it, we would like to say
what it means that the model supports the given IIT. For this we
define the signature algebra $\ADS$ which will provide notions of
algebras, displayed algebras and sections for each signature. This is
the same as the $\blank^\A$, $\blank^\D$ and $\blank^\S$ operations in
\cite{Kaposi:2019:CQI:3302515.3290315}. Before defining $\ADS$, we
illustrate its usage by an example.

\begin{example}[Algebras, displayed algebras and sections for natural
  numbers]
  For the signature of natural numbers as given in
  \Cref{ex:signatures}, algebras are given by the $\Sigma$-type
  $(N:\Set)\times N\times(N\ra N)$. A displayed algebra over $(N,z,s)$
  is given by the $\Sigma$-type
  \[
    (N^D:N\ra\Set)\times N^D\,z \times((n:N)\ra N^D\,n\ra N^D\,(s\,n)),
  \]
  and a section of a displayed algebra $(N^D,z^D,s^D)$ over $(N,z,s)$
  is given by the $\Sigma$-type
  \[
    (N^S:(n:N)\ra N^D\,n)\times (N^S\,z = z^D) \times((n:N)\ra N^S\,(s\,n) = s^D\,n\,(N^S\,n)).
  \]
  Displayed algebras over the initial algebra are called motives and
  methods of the eliminator, while a section of a displayed algebra
  over the initial algebra is the eliminator together with its
  computation rules.
\end{example}
  
\begin{definition}[The signature algebra $\ADS$]\label{def:ads}
  We define an element of $\SignAlg$ by listing all its components
  $\Con$, $\Ty$, $\Sub$, and so on, one per row. Each such components
  has three parts denoted by $^\A$, $^\D$ and $^\S$. The equality
  components of $\SignAlg$ are omitted as they are all reflexivity.
  \begin{alignat*}{10}
    & (\Gamma^\A:\Set) && \hspace{-0.3em}\times && (\Gamma^\D:\Gamma^\A\ra\Set) && \hspace{-0.3em}\times && (\Gamma^\S:(\gamma:\Gamma^\A)\ra\Gamma^\D\,\gamma\ra\Set) \\
    & (A^\A:\Gamma^\A\ra\Set) && \hspace{-0.3em}\times && (A^\D:\Gamma^\D\,\gamma\ra A^\A\,\gamma\ra\Set) && \hspace{-0.3em}\times && (A^\S:\Gamma^\S\,\gamma\,\gamma^D\ra(\alpha:A^\A\,\gamma)\ra \\
    & && && && && \hspace{1em} A^\D\,\gamma^D\,\alpha\ra\Set) \\
    & (\sigma^\A:\Gamma^\A\ra\Delta^\A) && \hspace{-0.3em}\times && (\sigma^\D:\Gamma^\D\,\gamma\ra\Delta^\D\,(\sigma^\A\,\gamma)) && \hspace{-0.3em}\times && (\sigma^\S:\Gamma^\S\,\gamma\,\gamma^D\ra \\
    & && && && && \hspace{1em} \Delta^\S\,(\sigma^\A\,\gamma)\,(\sigma^\D\,\gamma^D)) \\
    & (t^\A:(\gamma:\Gamma^\A)\ra A^\A\,\gamma) && \hspace{-0.3em}\times && (t^\D:(\gamma^D:\Gamma^\D\,\gamma)\ra && \hspace{-0.3em}\times && (t^\S:(\gamma^S:\Gamma^\S\,\gamma\,\gamma^D)\ra \\
    & && && \hspace{1em} A^\D\,\gamma^D\,(t^\A\,\gamma)) && && \hspace{1em}  A^\S\,(t^\A\,\gamma)\,(t^\D\,\gamma^D)) \\
    & \id^\A\,\gamma := \gamma && && \id^\D\,\gamma^D:=\gamma^D && && \id^\S\,\gamma^S := \gamma^S \\
    & (\sigma\circ\delta)^\A\,\gamma := \sigma^\A\,(\delta^\A\,\gamma) && && (\sigma\circ\delta)^\D\,\gamma^D := \sigma^\D\,(\delta^\D\,\gamma^D) && && (\sigma\circ\delta)^\S\,\gamma^S := \sigma^\S\,(\delta^\S\,\gamma^S) \\
    & (A[\sigma])^\A\,\gamma := A^\A\,(\sigma^\A\,\gamma) && && (A[\sigma])^\D\,\gamma^D := A^\D\,(\sigma^\D\,\gamma^D) && && (A[\sigma])^\S\,\gamma^S := A^\S\,(\sigma^\S\,\gamma^S) \\
    & (t[\sigma])^\A\,\gamma := t^\A\,(\sigma^\A\,\gamma) && && (t[\sigma])^\D\,\gamma^D := t^\D\,(\sigma^\D\,\gamma^D) && && (t[\sigma])^\S\,\gamma^S := t^\S\,(\sigma^\S\,\gamma^S) \\
    & \cdot^\A := \top && && \cdot^\D\,\_ := \top && && \cdot^\S\,\_\,\_ := \top \\
    & \epsilon^\A\,\_ := \tt && && \epsilon^\D\,\_ := \tt && && \epsilon^\S\,\_ := \tt \\
    & (\Gamma\rhd A)^\A := && && (\Gamma\rhd A)^\D\,(\gamma,\alpha) :=  && && (\Gamma\rhd A)^\S\,(\gamma,\alpha)\,(\gamma^D,\alpha^D) := \\
    & \hspace{1em} (\gamma:\Gamma^\A)\times A^\A\,\gamma && && \hspace{1em} (\gamma^D:\Gamma^\D\,\gamma)\times A^\D\,\gamma^D\,\alpha && && \hspace{1em} (\gamma^S:\Gamma^\S\,\gamma\,\gamma^D)\times A^\S\,\gamma^S\,\alpha\,\alpha^D \\
    & (\sigma,t)^\A\,\gamma := (\sigma^\A\,\gamma,t^\A\,\gamma) && && (\sigma,t)^\D\,\gamma^D := (\sigma^\D\,\gamma^D,t^\D\,\gamma^D) && && (\sigma,t)^\S\,\gamma^S := (\sigma^\S\,\gamma^S,t^\S\,\gamma^S) \\
    & (\pi_1\,\sigma)^\A\,\gamma := \proj_1\,(\sigma^\A\,\gamma) && && (\pi_1\,\sigma)^\D\,\gamma^D := \proj_1\,(\sigma^\D\,\gamma^D) && && (\pi_1\,\sigma)^\S\,\gamma^S := \proj_1\,(\sigma^\S\,\gamma^S) \\
    & (\pi_2\,\sigma)^\A\,\gamma := \proj_2\,(\sigma^\A\,\gamma) && && (\pi_2\,\sigma)^\D\,\gamma^D := \proj_2\,(\sigma^\D\,\gamma^D) && && (\pi_2\,\sigma)^\S\,\gamma^S := \proj_2\,(\sigma^\S\,\gamma^S) \\
    & \U^\A\,\gamma := \Set && && \U^\D\,\gamma^D\,T := T\ra\Set && && \U^\S\,\gamma^S\,T\,T^D := (\alpha:T)\ra T^D\,\alpha \\
    & (\El\,a)^\A\,\gamma := a^\A\,\gamma && && (\El\,a)^\D\,\gamma^D\,\alpha := a^\D\,\gamma^D\,\alpha && && (\El\,a)^\S\,\gamma^S\,\alpha\,\alpha^D := (a^\S\,\gamma^S\,\alpha = \alpha^D) \\
    & (\Pi\,a\,B)^\A\,\gamma := && && (\Pi\,a\,B)^\D\,\gamma^D\,f := && && (\Pi\,a\,B)^\S\,\gamma^S\,f\,f^D := (\alpha:a^\A\,\gamma)\ra \\
    & \hspace{1em} (\alpha:a^\A\,\gamma)\ra B^\A\,(\gamma,\alpha) && && \hspace{1em}  (\alpha^D:a^\D\,\gamma^D\,\alpha)\ra && && \hspace{1em} B^\S\,(\gamma^S,\refl_{a^\S\,\gamma^S\,\alpha})\,(f\,\alpha)\,\\
    & && && \hspace{1em}  B^\D\,(\gamma^D,\alpha^D)\,(f\,\alpha) && && \hspace{1em}\hphantom{B^\S\,}(f^D\,(a^\S\,\gamma^S\,\alpha)) \\
    & (t\oldapp u)^\A\,\gamma := t^\A\,\gamma\,(u^\A\,\gamma) && &&  (t\oldapp u)^\D\,\gamma^D := t^\D\,\gamma^D\,(u^\D\,\gamma^D) && &&  (t\oldapp u)^\S\,\gamma^S := u^\S\,\gamma^S \# t^\S\,\gamma^\S\,(u^\A\,\gamma) \\
    & (\Pim\,T\,B)^\A\,\gamma := && && (\Pim\,T\,B)^\D\,\gamma^D\,f := && && (\Pim\,T\,B)^\S\,\gamma^S\,f\,f^D := (\alpha:T)\ra \\
    & \hspace{1em} (\alpha:T)\ra(B\,\alpha)^\A\,\gamma && && \hspace{1em} (\alpha:T)\ra(B\,\alpha)^\D\,\gamma^D\,(f\,\alpha) && && \hspace{1em} (B\,\alpha)^\S\,\gamma^S\,(f\,\alpha)\,(f^D\,\alpha) \\
    & (t\appm \alpha)^\A\,\gamma := t^\A\,\gamma\,\alpha && && (t\appm \alpha)^\D\,\gamma^D := t^\D\,\gamma^D\,\alpha && && (t\appm \alpha)^\S\,\gamma^S := t^\S\,\gamma^S\,\alpha
  \end{alignat*}
\end{definition}
\Cref{def:ads} can be explained by columns (see
\cite[Sections 4 and 6]{Kaposi:2019:CQI:3302515.3290315} for more details) or by rows
(see \cite[Section 7.4]{Kaposi:2019:CQI:3302515.3290315}).

We first explain it by columns: the first column ($^A$ components)
corresponds to the standard model (set model, metacircular
interpretation \cite{ttintt}): contexts are sets, types are families,
terms are functions, the universe $\U$ is given by $\Set$, function
spaces are given by the external function space. The $^D$ column is a
logical predicate interpretation, $^\A$ and $^\D$ together are a unary
version of the parametric model for dependent types
\cite{10.1145/2535838.2535852}. Contexts are predicates, types are
families of predicates, terms say that the $^\A$ interpretation
respects the predicates (this is ususally called fundamental lemma of
the logical predicate). $\U$ is given by predicate space, the
predicate at a $\Pi$ type holds for a function if it respects the
predicates. For $\Pim$, the predicate is defined pointwise. The last
column ($^\S$) is a modified dependent logical relation which refers
to both $^A$ and $^\D$. Contexts are binary relations where the second
parameter depends on the first one, types are dependent variants of
this, terms say that the relation is respected by $^\A$ and $^\D$,
respectively. $\U$ is however not relation space, but a function and
$(\El\,a)^\S$ is the graph of the function $a^\S$. $\Pi^\S$ for a
function again says that the function respects the relation, however
we don't simply say
\[
  (\Pi\,a\,B)^\S\,\gamma^S\,f\,f^D := (\alpha:a^\A\,\gamma)(\alpha^D:a^\D\,\gamma^D\,\alpha)(\alpha^\S:(\El\,a)^\S\,\gamma^S\,\alpha\,\alpha^D)\ra B^\S\,\dots,
\]
as $(\El\,a)^\S\,\gamma^S\,\alpha\,\alpha^D$ is just an equality
$a^\S\,\gamma^S\,\alpha = \alpha^D$ which we can singleton
contract. So we omit $\alpha^D$ and this equality as an input and
replace $\alpha^D$ by $a^\S\,\gamma^S\,\alpha$ in the definition.

When viewing $\ADS$ by rows, we can see that it is a part of the CwF
model of type theory \cite[Section
7.4]{Kaposi:2019:CQI:3302515.3290315}. In the CwF model, a context is
given by a CwF. From the category, we only have objects ($\Gamma^\A$),
and from the families, we have the families for types $\Gamma^\D$ and
terms $\Gamma^\S$. Types are the corresponding parts of displayed
CwFs, substitutions are parts of CwF morphisms, terms are parts of CwF
sections. $\U$ is part of the CwF of sets, $\El\,a$ is the part of the
discrete displayed CwF coming from $a$ (which is a CwF-morphism from
$\Gamma$ to the CwF of sets). $\Pi$ is given as by a dependent product
of displayed CwFs where it is essential that the domain is discrete,
$\Pim$ is the pointwise direct product.

\begin{definition}[A model of ETT supports IITs]\label{sec:hasiits}
  A model of ETT supports IITs if for any signature signature
  $f:(M:\SignAlg)\ra\Con^M$ we have a $\con_f: (f\,\ADS)^\A$ and an
  $\elim_f : (\gamma^D:(f\,\ADS)^\D\,\con_f)\ra (f\,\ADS)^\S\,\con_f\,\gamma^D$.
\end{definition}
In other words, for any signature, we have an algebra called $\con$
(constructors) and for any displayed algebra over the constructors, we
have a section.

One can check that \Cref{sec:hasiits} gives the right
notion of constructors and elimination principle for the signatures in
\Cref{ex:signatures}.
\begin{example}[An IIT supports natural numbers]
  For the signature $nat$ of natural numbers in \Cref{ex:signatures},
  the type of $\con_{nat}$ is
  \begin{alignat*}{5}
    & ({nat}\,\ADS)^\A = \\
    & (\boldsymbol{\cdot}^\ADS\,\ext^\ADS\,\U^\ADS\,\ext^\ADS\,\El^\ADS\,0^\ADS\,\ext^\ADS\,1^\ADS \Ra^\ADS \El^\ADS\,1^\ADS)^\A = \\
    & \Big(\big((\boldsymbol{\cdot}\,\ext\,\U)\,\ext\,\El\,(\pi_2\,\id)\big)\,\ext\,(\pi_2\,(\pi_1\,\id)) \Ra \El\,(\pi_2\,(\pi_1\,\id))\Big)^\A = \\
    & \Big(\gamma'':\big(\gamma':((\gamma:\top)\times\Set)\big)\times(\proj_2\,\gamma')\Big)\times\big(\proj_2\,(\proj_1\,\gamma'')\ra\proj_2\,(\proj_1\,\gamma'')\big),
  \end{alignat*}
  which is the left-associated $\Sigma$ type isomorphic to its
  right-associated counterpart
  \[
    (N:\Set)\times \big(N \times (N\ra N)\big).
  \]
  Pretending that we always had the right-associated variant, the type
  of $\elim_{nat}$ computes as follows.
  \begin{alignat*}{5}
    & (\gamma^D:\,\, && ({nat}\,\ADS)^\D\,\con_{nat})\ra ({nat}\,\ADS)^\S\,\con_{nat}\,\gamma^D = \\
    & (\gamma^D:\,\, && (\boldsymbol{\cdot}^\ADS\,\ext^\ADS\,\U^\ADS\,\ext^\ADS\,\El^\ADS\,0^\ADS\,\ext^\ADS\,1^\ADS \Ra^\ADS \El^\ADS\,1^\ADS)^\D\,\con_{nat})\ra \\
    & && (\boldsymbol{\cdot}^\ADS\,\ext^\ADS\,\U^\ADS\,\ext^\ADS\,\El^\ADS\,0^\ADS\,\ext^\ADS\,1^\ADS \Ra^\ADS \El^\ADS\,1^\ADS)^\S\,\con_{nat}\,\gamma^D = \\
    & (\gamma^D:\,\, && (\boldsymbol{\cdot}^\ADS\,\ext^\ADS\,\U^\ADS\,\ext^\ADS\,\El^\ADS\,0^\ADS\,\ext^\ADS\,1^\ADS \Ra^\ADS \El^\ADS\,1^\ADS)^\D\,\con_{nat})\ra \\
    & && (\boldsymbol{\cdot}^\ADS\,\ext^\ADS\,\U^\ADS\,\ext^\ADS\,\El^\ADS\,0^\ADS\,\ext^\ADS\,1^\ADS \Ra^\ADS \El^\ADS\,1^\ADS)^\S\,\con_{nat}\,\gamma^D = \\
  \end{alignat*}
\end{example}

xxx

The definition of morphism is determined by the notion of algebra, it
can be computed following \cite{large_inf_qiit}, but we include it
here for completeness.
\begin{definition}[Signature morphism]\label{def:morphism}
  A morphism between signature algebras $M$ and $N$ consists of four
  functions and 17 equalities expressing that the functions preserve
  the operations of the two algebras. We use the same naming as in
  \Cref{def:algebra} and use superscripts to denote which algebra is
  meant.
\begin{alignat*}{5}
  & \rlap{(1) Substitution calculus} \\
  & \Con && : \Con^M && \ra\Con^N \\
  & \Ty  && : \Ty^M\,\Gamma && \ra\Ty^N\,(\Con\,\Gamma) \\
  & \Sub  && : \Sub^M\,\Gamma\,\Delta && \ra\Sub^N(\Con\,\Gamma)\,(\Con\,\Delta) \\
  & \Tm  && : \Tm^M\,\Gamma\,A && \ra\Tm^N\,(\Con\,\Gamma)\,(\Ty\,A) \\
  & \id && : \Sub\,\id^M && = \id^N \\
  & {\circ} && : \sigma\circ^M\delta && = \Sub\,\sigma\circ^N\Sub\,\delta \\
  & [] && : A[\sigma]^M && = \Ty\,A[\Sub\,\sigma]^N \\
  & [] && : t[\sigma]^M && = \Tm\,t[\Sub\,\sigma]^N \\
  & \boldsymbol{\cdot} && : \Con\,\boldsymbol{\cdot}^M && = \boldsymbol{\cdot}^N \\
  & \epsilon && : \Sub\,\epsilon^M && = \epsilon^N \\
  & \ext && : \Con\,(\Gamma\ext^M A) && = \Con\,\Gamma\ext^N\Ty\,A \\
  & , && : \Sub\,(\sigma,^M t) && = \Sub\,\sigma ,^N\Tm\,t \\
  & \pi_1 && : \Sub\,(\pi_1^M\,\sigma) && = \pi_1^N\,(\Sub\,\sigma) \\
  & \pi_2 && : \Tm\,(\pi_2^M\,\sigma) && = \pi_2^N\,(\Sub\,\sigma) \\
  & \rlap{(2) Universe} \\
  & \U && : \Ty\,\U^M && = \U^N \\
  & \El && : \Ty\,(\El^M\,a) && = \El^N\,(\Tm\,a) \\
  & \rlap{(3) Inductive parameters} \\
  & \Pi && : \Ty\,(\Pi^M\,a\,B) && = \Pi^N\,(\Tm\,a)\,(\Ty\,B) \\
  & \oldapp && : \Tm\,(t\mathbin{{\oldapp}^M} u) && = \Tm\,t\mathbin{{\oldapp}^N}\,\Tm\,u \\
  & \rlap{(4) External parameters} \\
  & \Pim && : \Ty\,(\Pim^M\,T\,B) && = \Pim^N\,T\,(\lambda\alpha.\Ty\,(B\,\alpha)) \\
  & \appm && : \Tm\,(t\mathbin{{\appm}^M}\alpha) && = \Tm\,t\mathbin{{\appm}^N}\alpha
\end{alignat*}
\end{definition}
\begin{definition}\label{def:theoryofsignatures}
  A model of ETT supports the theory of IIT signatures if there is a
  signature algebra equipped with a unique morphism into any
  algebra. We call this algebra the syntax or initial algebra, the
  morphism is called recursor.
\end{definition}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Constructing IITs from the Theory of IIT Signatures}
\label{sec:constructingiits}

In this section, we first specify what it means that a model of ETT
supports all IITs. In order to even say this, the model already has to
support the theory of IIT signatures as given in
\Cref{def:theoryofsignatures}. 

We construct all IITs describable by the theory of IIT signatures through the
term model construction of \cite{Kaposi:2019:CQI:3302515.3290315}. There, it is
shown that from the syntax of the theory of signatures for finitary QIITs, one
can construct any particular finitary QIIT. The idea is that for a signature
$\Gamma$, the initial algebra can be built from sets of terms of the form
$\Tm\,\Gamma\,(\El\,a)$. For example, considering the signature for natural
numbers
\[
  \Gamma := \big(\boldsymbol{\cdot}\,\ext\,N:\U\,\ext\,z : \El\,N\,\ext\,s : N \Ra \El\,N\big),
\]
we have that $\Tm\,\Gamma\,(\El\,N)$ is the set of natural numbers up to isomorphism,
since the only way to construct these terms is by using $s$ and $z$ from $\Gamma$.

In this section, we only need to check that the signatures and term model
construction in \cite{Kaposi:2019:CQI:3302515.3290315} restrict to IITs,
i.e.\ that from a syntax for the theory of IIT signatures all finitary IITs are
constructible.

\begin{enumerate}
\item
  Finitary IIT signatures are obtained exactly by dropping equality constructors from
  finitary QIIT signatures. It follows that any model for the theory of QIIT signatures
  restricts to IITs, hence we inherit the categorical semantics of QIITs.
\item
  The term model construction also restricts in a straightforward way. For QIITs,
  term algebras are constructed by induction on the syntax of signatures, and
  then another induction constructs the eliminator (i.e.\ dependent induction
  principle). In both cases, simply dropping equality constructors from the
  induction yields restriction to IITs.
\end{enumerate}

However, we shall mention that the Agda formalisation for the current paper
cannot be directly plugged into the Agda code for
\cite{Kaposi:2019:CQI:3302515.3290315} (which includes most of the term model
construction). One reason is that the QIIT formalisation uses strict computation
rules (given by Agda rewrite rules) for induction over signatures, while here we show propositional
computation. This mismatch can be in principle remedied by noting that both
formalisations use UIP and function extensionality, hence we can switch between
strict and propositional equalities, via the known translations between
extensional and intensional type
theories \cite{hofmann95extensional,winterhalter2019eliminating}.

Also, the current paper proves initiality, i.e.\ unique recursion for
signatures, while \cite{Kaposi:2019:CQI:3302515.3290315} uses dependent
elimination. We expect that the two notions are equivalent. An extension of
\cite{Kaposi:2019:CQI:3302515.3290315} to large infinitary QIITs would entail
this equivalence, since that would cover the (large, infinitary) theory of IIT
signatures.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Constructing the Theory of IIT Signatures}
\label{sec:ambroise}

\input{universaliit}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Further Work}

The current work only concerns finitary IITs. An extension would be to also
allow infinitely branching inductive types such as W-types. This would first
require giving semantics for infinitary IITs (to our knowledge there is no
previously published semantics that we can borrow), and also giving a term model
construction analogously to finitary QIITs. These steps seem feasible. However,
it seems to be more difficult to construct the syntax of infinitary IIT
signatures without using quotients. The reason is that such syntax would not be
strictly restricted to neutral terms: we would need $\lambda$-abstraction and
$\beta\eta$-rules for infinitary $\Pi$ types, in order to allow a term model
construction for infinitary IITs. A definition of normal preterms and typing
judgments on them may still be possible, but it appears to be much more
complicated than before (the current authors have attempted this without
conclusive success).

As mentioned in Section \ref{sec:right_uniqueness}, it also remains an open
problem whether IITs are reducible to inductive types in a UIP-free setting. To
show this, we would need to construct the syntax of signatures without UIP, and
also reproduce the semantics and term model construction for IITs without UIP.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\bibliography{b}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage

\appendix

\end{document}
